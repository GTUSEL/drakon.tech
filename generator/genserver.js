var _ = require('lodash')
var esprima = require('esprima')
var escodegen = require('escodegen')

var INDENT = "    "
var globals = {}
var globalForbidVar = true

var completeMethod = "onChildCompleted"

// Autogenerated with DRAKON Editor 1.33


function abnormalLoop(loop, doneLoops, exits) {
    while (true) {
        if (loop) {
            
        } else {
            return false
        }
        if ((loop.id in doneLoops) && (!(loop.id in exits))) {
            return true
        }
        loop = loop.parentLoop
    }
}

function addAddress(seq, item) {
    var items, last, prim, text
    if (hasReturn(seq)) {
        
    } else {
        text = "return branch" + 
        	item.branchId +
        	"();"
        prim = createAddress(text)
        items = seq.items
        last = items.length - 1
        if ((items.length === 0) || (!(items[last].type === "break"))) {
            items.push(prim)
        } else {
            items[last] = prim
        }
    }
}

function addAwait(machine, method, state, variable, next) {
    var awaits, item
    awaits = getCreateArray(
        machine.awaits,
        method
    )
    item = {
        state : state,
        variable : variable,
        next : next
    }
    awaits.push(item)
}

function addBreak(seq, prev, item, loop) {
    var step
    if ((loop) && (loop.id)) {
        if (convergeWithParent(item, loop)) {
            return true
        } else {
            if (((prev) && (loop.id in item.loops)) && (_.includes(item.prev, prev))) {
                removeFromPrev(item, prev)
                if (hasReturn(seq)) {
                    return false
                } else {
                    step = createBreak()
                    seq.items.push(step)
                    return false
                }
            } else {
                return false
            }
        }
    } else {
        return false
    }
}

function addBroken(prev, item) {
    if (prev.one === item) {
        prev.oneBroken = true
    }
    if (prev.two === item) {
        prev.twoBroken = true
    }
}

function addCase(sw, value) {
    var seq
    seq = createSeq()
    sw.cases.push({
    	value: value,
    	seq: seq
    })
    return seq
}

function addCompleted(seq, value) {
    var text
    addLine(seq, "self.state = undefined;")
    text = "sm.sendMessage(self.parent, \"" +
      completeMethod + "\", " + value + ");"
    addLine(seq, text)
    addLine(seq, "work = false;")
}

function addDiagramError(build, diagram, message) {
    var error, id
    id = makeId(diagram)
    error = {
        type : "folder",
        name : diagram.name,
        target : id,
        message : translate(build, message)
    }
    build.state = "error"
    build.errors.push(error)
}

function addFakeLoopEnd(diagram, item) {
    var fakeEnd
    fakeEnd = createItem(
        diagram.work,
        "_" + item.id + "_end",
        "action",
        ""
    )
    fakeEnd.one = item
    fakeEnd.prev = item.aprev
    item.aprev = [fakeEnd]
    var _ind1704 = 0;
    var _col1704 = fakeEnd.prev;
    var _len1704 = _col1704.length;
    while (true) {
        if (_ind1704 < _len1704) {
            
        } else {
            break;
        }
        var prev = _col1704[_ind1704];
        if (prev.one === item) {
            prev.one = fakeEnd
        }
        if (prev.two === item) {
            prev.two = fakeEnd
        }
        _ind1704++;
    }
}

function addFlag(node, flag, acc) {
    if (flag in node.flags) {
        return acc + flag + " "
    } else {
        return acc
    }
}

function addItemError(build, diagram, itemId, message) {
    var error, id
    id = makeId(diagram)
    error = {
        type : "item",
        name : diagram.name,
        target : {id:id, itemId:itemId},
        message : translate(build, message)
    }
    build.state = "error"
    build.errors.push(error)
}

function addLine(seq, text) {
    var step
    step = createPrim(text)
    seq.items.push(step)
}

function addNext(seq, id) {
    addLine(
      seq,
      "self.state = \"" + id + "\";")
}

function addQuestion(seq, node) {
    var step
    step = createIf(node.text, node.flag1)
    seq.items.push(step)
    return step
}

function addScenarioStep(machine, node) {
    var seq
    if (node.id in machine.visited) {
        
    } else {
        machine.visited[node.id] = true
        seq = addCase(machine.sw, node.id)
        appendStepCore(
            machine,
            seq,
            node
        )
    }
}

function addSilBranches(diagram) {
    var body, work
    work = diagram.work
    body = work.fun.body.items
    var _ind2113 = 0;
    var _col2113 = work.branches;
    var _len2113 = _col2113.length;
    while (true) {
        if (_ind2113 < _len2113) {
            
        } else {
            break;
        }
        var branch = _col2113[_ind2113];
        body.push(
            branch.fun
        )
        _ind2113++;
    }
    body.push(
    	createPrim("return branch1();")
    )
}

function addThrow(step, value) {
    var text
    if (value[value.length - 1] === ";") {
        value = value.substring(0, value.length - 1)
    }
    text = "sm.handleError(self, " + value + ");"
    addLine(step, text)
    addLine(step, "work = false;")
}

function addToSameTarget(oldItem, newItem) {
    var next
    next = oldItem.one
    newItem.one = next
    if (isArrow(oldItem, next)) {
        next.aprev.push(newItem)
    } else {
        next.prev.push(newItem)
    }
}

function addVariablesDec(diagram) {
    var step, text, work
    work = diagram.work
    if (work.vars.length === 0) {
        
    } else {
        text = "var " + work.vars.join(", ") + ";"
        step = createPrim(text)
        work.fun.body.items.unshift(step)
    }
}

function and(left, right) {
    return "(" + left + ") && (" +
      right + ")"
}

function appendAction(machine, step, node) {
    var retLength, value
    if (startsWithWord(node.text, "return")) {
        retLength = "return ".length
        value = node.text.substring(retLength).trim()
        addCompleted(step, value)
    } else {
        if (node.text === "return") {
            addCompleted(step, "undefined")
        } else {
            if (startsWithWord(node.text, "throw")) {
                retLength = "throw ".length
                value = node.text.substring(retLength).trim()
                addThrow(step, value)
            } else {
                addLine(step, node.text)
                appendScenarioStep(
                    machine,
                    step,
                    node.one
                )
            }
        }
    }
}

function appendAddress(machine, seq, node) {
    var branch, next
    branch = getBranchById(
        machine,
        node.branchId
    )
    next = branch.one
    addNext(seq, next.id)
    addScenarioStep(
        machine,
        next
    )
}

function appendEnd(machine, step, node) {
    addCompleted(step, "undefined")
}

function appendInput(machine, seq, node) {
    addAwait(
        machine,
        node.text2,
        node.id,
        node.text,
        node.one.id
    )
    addLine(seq, "self.state = \"" + 
      waitState(node.id) + "\";")
    addLine(seq, "work = false;")
    addScenarioStep(
        machine,
        node.one
    )
}

function appendInsertion(machine, seq, node) {
    var body, callExpr, callNode, expr, statement, variable
    var _sw29170000_ = 0;
    if (node.text) {
        body = getBody(node)
        if (body.length === 1) {
            statement = body[0]
            if (statement.type === "ExpressionStatement") {
                expr = statement.expression
                _sw29170000_ = expr.type;
                if (_sw29170000_ === "AssignmentExpression") {
                    variable = escodegen.generate(expr.left)
                    callNode = expr.right
                    callNode.arguments.unshift({
                    	type: "Identifier",
                    	name: "self"
                    })
                    callExpr = escodegen.generate(callNode)
                    addAwait(
                        machine,
                        completeMethod,
                        node.id,
                        variable,
                        node.one.id
                    )
                    addLine(seq, "self.state = \"" + 
                      waitState(node.id) + "\";")
                    addLine(seq, "work = false;")
                    addLine(seq, "var machine = " + callExpr + ";")
                    addLine(seq, "machine.run();")
                    addScenarioStep(
                        machine,
                        node.one
                    )
                } else {
                    if (_sw29170000_ === "CallExpression") {
                        variable = undefined
                        callNode = expr
                        callNode.arguments.unshift({
                        	type: "Identifier",
                        	name: "self"
                        })
                        callExpr = escodegen.generate(callNode)
                        addAwait(
                            machine,
                            completeMethod,
                            node.id,
                            variable,
                            node.one.id
                        )
                        addLine(seq, "self.state = \"" + 
                          waitState(node.id) + "\";")
                        addLine(seq, "work = false;")
                        addLine(seq, "var machine = " + callExpr + ";")
                        addLine(seq, "machine.run();")
                        addScenarioStep(
                            machine,
                            node.one
                        )
                    } else {
                        addItemError(
                            machine.build,
                            machine.diagram,
                            node.id,
                            globals.strings.BUILD_ERROR_INSERTION
                        )
                    }
                }
            } else {
                addItemError(
                    machine.build,
                    machine.diagram,
                    node.id,
                    globals.strings.BUILD_ERROR_INSERTION
                )
            }
        } else {
            addItemError(
                machine.build,
                machine.diagram,
                node.id,
                globals.strings.BUILD_ERROR_INSERTION
            )
        }
    } else {
        addItemError(
            machine.build,
            machine.diagram,
            node.id,
            globals.strings.BUILD_EMPTY_INSERTION
        )
    }
}

function appendPause(machine, seq, node) {
    var text
    addAwait(
        machine,
        "onTimeout",
        node.id,
        undefined,
        node.one.id
    )
    addLine(seq, "self.state = \"" + 
      waitState(node.id) + "\";")
    addLine(seq, "work = false;")
    text = "sm.sendMessage(self, \"onTimeout\", " +
     "undefined, " + node.text + ");"
    addLine(seq, text)
    addScenarioStep(
        machine,
        node.one
    )
}

function appendQuestion(machine, seq, node) {
    var qnode
    qnode = addQuestion(seq, node)
    appendScenarioStep(
        machine,
        qnode.right,
        node.two
    )
    appendScenarioStep(
        machine,
        qnode.down,
        node.one
    )
}

function appendReceive(machine, seq, node) {
    var current, names
    addLine(seq, "self.state = \"" + 
      waitState(node.id) + "\";")
    addLine(seq, "work = false;")
    current = node.one
    while (true) {
        if (current.text) {
            names = parseReceiveCase(current.text)
            if (names) {
                addAwait(
                    machine,
                    names.functionName,
                    node.id,
                    "self." + names.argName,
                    current.one.id
                )
                addScenarioStep(
                    machine,
                    current.one
                )
            } else {
                addItemError(
                	machine.build,
                	machine.diagram,
                	current.id,
                	"BUILD_BAD_RECEIVE_CASE"
                )
            }
        } else {
            addItemError(
            	machine.build,
            	machine.diagram,
            	current.id,
            	"BUILD_EMPTY_RECEIVE_CASE"
            )
        }
        current = current.two
        if (current) {
            
        } else {
            break;
        }
    }
}

function appendScenarioStep(machine, seq, node) {
    if ((node.prev.length > 1) || (node.type === "arrow-loop")) {
        addNext(seq, node.id)
        addScenarioStep(
            machine,
            node
        )
    } else {
        appendStepCore(
            machine,
            seq,
            node
        )
    }
}

function appendStepCore(machine, seq, node) {
    var _sw25970000_ = 0;
    _sw25970000_ = node.type;
    if (_sw25970000_ === "arrow-loop") {
        appendScenarioStep(
            machine,
            seq,
            node.one
        )
    } else {
        if (_sw25970000_ === "input") {
            appendInput(
                machine,
                seq,
                node
            )
        } else {
            if (_sw25970000_ === "pause") {
                appendPause(
                    machine,
                    seq,
                    node
                )
            } else {
                if (_sw25970000_ === "insertion") {
                    appendInsertion(
                        machine,
                        seq,
                        node
                    )
                } else {
                    if (_sw25970000_ === "end") {
                        appendEnd(
                            machine,
                            seq,
                            node
                        )
                    } else {
                        if (_sw25970000_ === "branch") {
                            appendScenarioStep(
                                machine,
                                seq,
                                node.one
                            )
                        } else {
                            if (_sw25970000_ === "question") {
                                appendQuestion(
                                    machine,
                                    seq,
                                    node
                                )
                            } else {
                                if (_sw25970000_ === "address") {
                                    appendAddress(
                                        machine,
                                        seq,
                                        node
                                    )
                                } else {
                                    if (_sw25970000_ === "select") {
                                        appendReceive(
                                            machine,
                                            seq,
                                            node
                                        )
                                    } else {
                                        appendAction(
                                            machine,
                                            seq,
                                            node
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function assign(varName, value) {
    return varName + " = " + value + ";"
}

function awaitName(diagram, name) {
    return diagram.name + "_" + name
}

function beginBuild(build) {
    var _sw22090000_ = 0;
    checkUniqueNames(build)
    writeBlock(
        build,
        "roof"
    )
    build.lines.push(
       "// Created with Drakon Tech https://drakon.tech/\n"
    )
    _sw22090000_ = build.props.mformat;
    if (_sw22090000_ === "MES_IFFE") {
        build.lines.push("(function() {\n")
    } else {
        if (_sw22090000_ === "MES_FUNCTION") {
            build.lines.push("function " + 
            	build.name + "() {\n")
            build.lines.push("var module = {};\n")
        }
    }
    writeBlock(
        build,
        "header"
    )
}

function bindItemsToLoop(map, loopId, item) {
    var idata
    while (true) {
        idata = map[item.id]
        if ((loopId in idata.loops) || (item.id === loopId)) {
            break;
        }
        idata.loops[loopId] = 1
        var _ind1833 = 0;
        var _col1833 = item.prev;
        var _len1833 = _col1833.length;
        while (true) {
            if (_ind1833 < _len1833) {
                
            } else {
                break;
            }
            var prev = _col1833[_ind1833];
            bindItemsToLoop(
                map,
                loopId,
                prev
            )
            _ind1833++;
        }
    }
}

function bindItemsToLoops(work, map) {
    var _ind1812 = 0;
    var _col1812 = work.items;
    var _keys1812 = Object.keys(_col1812); 
    var _len1812 = _keys1812.length;
    while (true) {
        if (_ind1812 < _len1812) {
            
        } else {
            break;
        }
        var id = _keys1812[_ind1812]; var item = _col1812[id];
        if (item.type === "arrow-loop") {
            bindItemsToLoop(
                map,
                item.id,
                item.aprev[0]
            )
        }
        _ind1812++;
    }
}

function buildAwait(build, diagram, aname, states) {
    var fun, seq, sw
    fun = createFunction(
        awaitName(diagram, aname),
        ["self", "data"],
        {}
    )
    sw = createSwitch("self.state")
    sw.defReturn = true
    fun.body.items.push(sw)
    var _ind2866 = 0;
    var _col2866 = states;
    var _len2866 = _col2866.length;
    while (true) {
        if (_ind2866 < _len2866) {
            
        } else {
            break;
        }
        var state = _col2866[_ind2866];
        seq = addCase(sw, waitState(state.state))
        if (state.variable) {
            addLine(seq, state.variable + " = data;")
        }
        addLine(seq, "self.state = \"" + 
          state.next + "\";")
        _ind2866++;
    }
    addLine(fun.body, runName(diagram) + "(self);")
    printNode(
        fun,
        0,
        build.lines
    )
}

function buildBody(build, diagram) {
    var context, flags, work
    var _sw23000000_ = 0;
    work = diagram.work
    findParentLoops(
        work
    )
    var _ind887 = 0;
    var _col887 = work.branches;
    var _len887 = _col887.length;
    while (true) {
        if (_ind887 < _len887) {
            
        } else {
            break;
        }
        var branch = _col887[_ind887];
        context = {
            subtrees : {},
            items : work.items,
            build : build,
            diagram : diagram
        }
        findBlockEnds(
            branch.item,
            branch.item.one,
            [],
            context
        )
        _ind887++;
    }
    flags = chooseFlags(
        build,
        diagram,
        work.flags
    )
    work.fun = createFunction(
        diagram.name,
        work.args,
        flags
    )
    var _ind1041 = 0;
    var _col1041 = work.branches;
    var _len1041 = _col1041.length;
    while (true) {
        if (_ind1041 < _len1041) {
            
        } else {
            break;
        }
        var branch = _col1041[_ind1041];
        branch.fun = createBranchFunction(
            branch.item.branchId,
            flags
        )
        scanSequence(
            branch.fun.body,
            branch.item,
            branch.item.one,
            "",
            "",
            false
        )
        _ind1041++;
    }
    _sw23000000_ = work.branches.length;
    if (_sw23000000_ === 0) {
        
    } else {
        if (_sw23000000_ === 1) {
            work.fun.body = work.branches[0].fun.body
        } else {
            checkEnd(
                build,
                diagram
            )
            checkOrphaneBranches(
                build,
                diagram
            )
            replaceAddresses(
                diagram
            )
            addSilBranches(
                diagram
            )
        }
    }
    addVariablesDec(
        diagram
    )
    diagram.output = {
        flags : work.flags
    }
}

function buildEnds(item, context) {
    var branching, exits, gitem, grouped, loop, p2, parentLoop
    grouped = _.groupBy(
        item.dangling
    )
    p2 = []
    exits = {}
    var _ind938 = 0;
    var _col938 = grouped;
    var _keys938 = Object.keys(_col938); 
    var _len938 = _keys938.length;
    while (true) {
        if (_ind938 < _len938) {
            
        } else {
            break;
        }
        var id = _keys938[_ind938]; var group = _col938[id];
        branching = context.subtrees[id]
        if (group.length > 1) {
            branching -= (group.length - 1)
            context.subtrees[id] = branching
        }
        _ind938++;
    }
    var _ind1431 = 0;
    var _col1431 = grouped;
    var _keys1431 = Object.keys(_col1431); 
    var _len1431 = _keys1431.length;
    while (true) {
        if (_ind1431 < _len1431) {
            
        } else {
            break;
        }
        var id = _keys1431[_ind1431]; var group = _col1431[id];
        branching = context.subtrees[id]
        if ((branching <= 0) && (!(isLoop(context, id)))) {
            gitem = context.items[id]
            parentLoop = gitem.parentLoop
            if (parentLoop) {
                loop = parentLoop.id
                if ((context.subtrees[loop] === 0) && (!(parentLoop === item.parentLoop))) {
                    exits[loop] = true
                }
            }
        }
        _ind1431++;
    }
    var _ind1364 = 0;
    var _col1364 = grouped;
    var _keys1364 = Object.keys(_col1364); 
    var _len1364 = _keys1364.length;
    while (true) {
        if (_ind1364 < _len1364) {
            
        } else {
            break;
        }
        var id = _keys1364[_ind1364]; var group = _col1364[id];
        branching = context.subtrees[id]
        if (branching <= 0) {
            if (isLoop(context, id)) {
                if (exits[id]) {
                    
                } else {
                    p2.push(id)
                }
            } else {
                gitem = context.items[id]
                parentLoop = gitem.parentLoop
                if (isHierarchyBroken(gitem, item)) {
                    
                } else {
                    if (parentLoop) {
                        loop = parentLoop.id
                        if (exits[loop]) {
                            item.ends.push(id)
                            item.ends.push(loop)
                            item.loops[loop] = true
                        } else {
                            if (group.length > 1) {
                                item.ends.push(id)
                            } else {
                                p2.push(id)
                            }
                        }
                    } else {
                        if (group.length > 1) {
                            item.ends.push(id)
                        } else {
                            p2.push(id)
                        }
                    }
                }
            }
        } else {
            p2.push(id)
        }
        _ind1364++;
    }
    item.dangling = p2
}

function buildScenario(build, diagram) {
    var args, branches, ctr, first, loop, machine, run, sw, text
    branches = diagram.work.branches
    run = createFunction(
        runName(diagram),
        ["self"],
        {}
    )
    if (branches.length === 0) {
        text = "sm.sendMessage(self.parent, \"" +
          completeMethod + "\", undefined);"
        addLine(run.body, text)
    } else {
        first = branches[0].item.one
        addLine(run.body, "var work = true;")
        loop = createWhile("work")
        run.body.items.push(loop)
        sw = createSwitch("self.state")
        sw.defReturn = true
        loop.body.items.push(sw)
        machine = {
            build : build,
            diagram : diagram,
            sw : sw,
            visited : {},
            awaits : {}
        }
        addScenarioStep(
            machine,
            first
        )
    }
    args = _.clone(diagram.work.args)
    args.unshift("parent")
    ctr = createFunction(
        diagram.name,
        args,
        {}
    )
    addLine(ctr.body, "var self = sm.createMachine(\"" + 
      diagram.name + "\");")
    var _ind2800 = 0;
    var _col2800 = diagram.work.args;
    var _len2800 = _col2800.length;
    while (true) {
        if (_ind2800 < _len2800) {
            
        } else {
            break;
        }
        var arg = _col2800[_ind2800];
        addLine(ctr.body, "self." + arg +
         " = " + arg + ";")
        _ind2800++;
    }
    var _ind2833 = 0;
    var _col2833 = machine.awaits;
    var _keys2833 = Object.keys(_col2833); 
    var _len2833 = _keys2833.length;
    while (true) {
        if (_ind2833 < _len2833) {
            
        } else {
            break;
        }
        var aname = _keys2833[_ind2833]; var avalue = _col2833[aname];
        addLine(ctr.body, "sm.addMethod(self, \"" + 
          aname + "\", " +
          awaitName(diagram, aname) + ");")
        _ind2833++;
    }
    addLine(ctr.body, "sm.addChild(parent, self);")
    addLine(ctr.body, "sm.addMethod(self, \"run\", " +
      runName(diagram) + ");")
    if (first === undefined) {
        addLine(ctr.body, "self.state = \"" +
           "created\";")
    } else {
        addLine(ctr.body, "self.state = \"" +
           first.id + "\";")
    }
    addLine(ctr.body, "return self;")
    var _ind2847 = 0;
    var _col2847 = machine.awaits;
    var _keys2847 = Object.keys(_col2847); 
    var _len2847 = _keys2847.length;
    while (true) {
        if (_ind2847 < _len2847) {
            
        } else {
            break;
        }
        var aname = _keys2847[_ind2847]; var avalue = _col2847[aname];
        buildAwait(
            build,
            diagram,
            aname,
            avalue
        )
        _ind2847++;
    }
    diagram.output = {
        flags : diagram.work.flags
    }
    printNode(
        run,
        0,
        build.lines
    )
    printNode(
        ctr,
        0,
        build.lines
    )
}

function buildVariableList(work) {
    work.vars = _.difference(
    	Object.keys(work.assigned),
    	Object.keys(work.declared)
    )
    work.vars.sort()
}

function canShortCircuit(item) {
    if (((item) && (item.type === "question")) && (item.prev.length === 1)) {
        return true
    } else {
        return false
    }
}

function checkEnd(build, diagram) {
    var _ind2067 = 0;
    var _col2067 = diagram.work.items;
    var _keys2067 = Object.keys(_col2067); 
    var _len2067 = _keys2067.length;
    while (true) {
        if (_ind2067 < _len2067) {
            
        } else {
            addDiagramError(
                build,
                diagram,
                "BUILD_NO_END"
            )
            break;
        }
        var id = _keys2067[_ind2067]; var item = _col2067[id];
        if (item.type === "end") {
            break;
        }
        _ind2067++;
    }
}

function checkOrphaneBranches(build, diagram) {
    var branchItem, branches, count, i, input, referenced, work
    work = diagram.work
    input = diagram.input
    branches = work.branches
    referenced = {}
    var _ind2095 = 0;
    var _col2095 = input.items;
    var _keys2095 = Object.keys(_col2095); 
    var _len2095 = _keys2095.length;
    while (true) {
        if (_ind2095 < _len2095) {
            
        } else {
            break;
        }
        var id = _keys2095[_ind2095]; var item = _col2095[id];
        if (item.one) {
            referenced[item.one] = true
            if (item.two) {
                referenced[item.two] = true
            }
        }
        _ind2095++;
    }
    count = branches.length
    i = 1;
    while (true) {
        if (i < count) {
            
        } else {
            break;
        }
        branchItem = branches[i].item
        if (branchItem.id in referenced) {
            
        } else {
            addItemError(
                build,
                diagram,
                branchItem.id,
                "BUILD_BRANCH_NOT_REFERENCED"
            )
        }
        i++;
    }
}

function checkUniqueNames(build) {
    var grouped = _.groupBy(
        build.diagrams,
        "name"
    )
    var _ind2178 = 0;
    var _col2178 = grouped;
    var _keys2178 = Object.keys(_col2178); 
    var _len2178 = _keys2178.length;
    while (true) {
        if (_ind2178 < _len2178) {
            
        } else {
            break;
        }
        var name = _keys2178[_ind2178]; var group = _col2178[name];
        if (group.length > 1) {
            addDiagramError(
                build,
                group[0],
                "BUILD_DIAGRAM_NAME_NOT_UNIQUE"
            )
        }
        _ind2178++;
    }
}

function chooseFlags(build, diagram, flags) {
    var mformat, result
    mformat = build.props.mformat
    result = _.clone(flags)
    if (("default" in flags) && (!(mformat === "MES_ES6"))) {
        delete result["default"]
    }
    if (("export" in flags) && (!(mformat === "MES_ES6"))) {
        delete result["export"]
    }
    return result
}

function completeBuild(build) {
    var _sw21960000_ = 0;
    writeBlock(
        build,
        "footer"
    )
    _sw21960000_ = build.props.mformat;
    if (_sw21960000_ === "MES_IFFE") {
        build.lines.push("})();\n")
    } else {
        if (_sw21960000_ === "MES_FUNCTION") {
            completeFactory(build)
        } else {
            if (_sw21960000_ === "MES_COMMONJS") {
                completeCommon(build)
            }
        }
    }
    writeBlock(
        build,
        "basement"
    )
}

function completeCommon(build) {
    var addToModule, exported
    exported = getExported(build)
    addToModule = function(diagram) {
    	build.lines.push(
    		"module.exports." +
    		diagram.name + " = " + 
    		diagram.name + ";\n")
    }
    build.lines.push("module.exports = {};\n")
    exported.forEach(addToModule)
}

function completeFactory(build) {
    var addToModule, exported
    exported = getExported(build)
    addToModule = function(diagram) {
    	build.lines.push("module." + 
    		diagram.name + " = " + 
    		diagram.name + ";\n")
    }
    exported.forEach(addToModule)
    build.lines.push("return module;\n")
    build.lines.push("}\n")
}

function completeLoop(item, context) {
    var _ind1187 = 0;
    var _col1187 = item.adangling;
    var _len1187 = _col1187.length;
    while (true) {
        if (_ind1187 < _len1187) {
            
        } else {
            break;
        }
        var id = _col1187[_ind1187];
        context.subtrees[id]--
        if (_.includes(item.dangling, id)) {
            
        } else {
            item.ends.push(id)
        }
        _ind1187++;
    }
}

function connectItem(work, item, visited) {
    if (item.id in visited) {
        
    } else {
        visited[item.id] = true
        item.one = connectItemLink(
            work,
            item,
            item.one,
            visited
        )
        item.two = connectItemLink(
            work,
            item,
            item.two,
            visited
        )
    }
}

function connectItemLink(work, item, nextId, visited) {
    var address, next
    var _sw1240000_ = 0;
    if (nextId) {
        next = work.items[nextId]
        _sw1240000_ = next.type;
        if (_sw1240000_ === "end") {
            next.prev.push(item)
            return next
        } else {
            if (_sw1240000_ === "branch") {
                address = createItem(
                    work,
                    undefined,
                    "address",
                    next.text
                )
                address.branchId = next.branchId
                address.prev.push(item)
                return address
            } else {
                if ((_sw1240000_ === "arrow-loop") && (isBefore(next, item))) {
                    next.aprev.push(item)
                } else {
                    next.prev.push(item)
                    connectItem(
                        work,
                        next,
                        visited
                    )
                }
                return next
            }
        }
    } else {
        return undefined
    }
}

function convergeWithParent(item, loop) {
    while (true) {
        loop = loop.parentLoop
        if (loop) {
            
        } else {
            return false
        }
        if (loop.id in item.loops) {
            return true
        }
    }
}

function copyItem(item) {
    var copy
    copy = _.clone(item)
    copy.prev = []
    copy.aprev = []
    copy.dangling = []
    copy.ends = []
    copy.closing = 0
    copy.adangling = []
    copy.aclosing = 0
    copy.loops = {}
    return copy
}

function countAsExit(item, context, paths) {
    var _ind1958 = 0;
    var _col1958 = paths;
    var _len1958 = _col1958.length;
    while (true) {
        if (_ind1958 < _len1958) {
            
        } else {
            break;
        }
        var id = _col1958[_ind1958];
        if (_.includes(item.parentLoop.dangling, id)) {
            
        } else {
            context.subtrees[id]--
        }
        _ind1958++;
    }
}

function createAddress(text) {
    return {
        type : "address",
        text : text,
        print : printPrim
    }
}

function createBranchFunction(branchId, flags) {
    var flags2
    flags2 = {}
    if (flags["async"]) {
        flags2["async"] = true
    }
    return createFunction(
        "branch" + branchId,
        [],
        flags2
    )
}

function createBreak() {
    return {
        type : "break",
        print : printBreak
    }
}

function createFunction(name, args, flags) {
    return {
        type : "function",
        name : name,
        args : _.clone(args),
        flags : _.clone(flags),
        body : createSeq(),
        print : printFunction
    }
}

function createIf(condition, flag1) {
    return {
        type : "if",
        condition : condition,
        flag1 : flag1,
        down : createSeq(),
        right : createSeq(),
        print : printIf
    }
}

function createItem(work, id, type, text) {
    var fields, item
    if (id) {
        
    } else {
        id = "_auto_" + work.nextId
        work.nextId++
    }
    fields = {
        id : id,
        type : type,
        text : text
    }
    item = copyItem(fields)
    work.items[id] = item
    return item
}

function createItemsMap(work) {
    var copy, map
    map = {}
    var _ind1803 = 0;
    var _col1803 = work.items;
    var _keys1803 = Object.keys(_col1803); 
    var _len1803 = _keys1803.length;
    while (true) {
        if (_ind1803 < _len1803) {
            
        } else {
            break;
        }
        var id = _keys1803[_ind1803]; var item = _col1803[id];
        copy = {
            id : id,
            type : item.type,
            loops : {}
        }
        map[id] = copy
        _ind1803++;
    }
    return map
}

function createPrim(text) {
    return {
        type : "prim",
        text : text,
        print : printPrim
    }
}

function createReturn() {
    return createPrim("return;")
}

function createSeq() {
    return {
        type : "seq",
        items : [],
        print : printSeq
    }
}

function createStrings() {
    var strings
    strings = {}
    strings.BUILD_NO_END = "This diagram does not have an end"
    strings.BUILD_BRANCH_NOT_REFERENCED = "Branch is not referenced"
    strings.BUILD_DIAGRAM_NAME_NOT_UNIQUE = "Diagram name is not unique"
    strings.BUILD_NO_VAR = "\"var\" keyword is not allowed in DRAKON diagrams"
    strings.BUILD_NO_CONST = "\"const\" keyword is not allowed. Declaration of variables is automatic in a DRAKON diagram"
    strings.BUILD_NO_LET = "\"let\" keyword is not allowed. Declaration of variables is automatic in a DRAKON diagram"
    strings.BUILD_BAD_DECLARATION = "Unsupported declaration"
    strings.BUILD_BAD_LOOP = "Error in the loop statement"
    strings.BUILD_EXPRESSION_EXPECTED = "Expression expected"
    strings.BUILD_BAD_FLAG = "Unsupported keyword"
    strings.BUILD_ONE_EXPRESSION_EXPECTED = "One expression expected"
    strings.BUILD_ASSIGNMENT_NOT_ALLOWED = "Assignment is not allowed here"
    strings.BUILD_BAD_LOOP_VARIABLE = "This loop variable is declared or assigned elsewhere"
    strings.BUILD_EMPTY_CASE_NOT_LAST = "Only last Case icon can be empty"
    strings.BUILD_NO_VAR_SCEN = "Local variables are not allowed in scenarios"
    strings.BUILD_EMPTY_RECEIVE_CASE = "Empty Case icons are not allowed in \"receive\" construct"
    strings.BUILD_BAD_RECEIVE_CASE = "Bad expression under  \"receive\" construct. Expected: foo(bar)"
    strings.BUILD_EMPTY_INSERTION = "An insertion icon cannot be empty. Add a function call expression " +
     "and an optional assignment"
    strings.BUILD_ERROR_INSERTION = "Error in the insertion icon. Expected a function call expression " +
     "and an optional assignment"
    strings.BUILD_EXIT_FROM_NESTED = "Exit from a nested loop is not supported"
    return strings
}

function createSwitch(condition) {
    return {
        type : "switch",
        condition : condition,
        cases : [],
        print : printSwitch
    }
}

function createWhile(condition) {
    return {
        type : "while",
        body : createSeq(),
        print : printWhile,
        condition : condition || "true"
    }
}

function cutOffComment(text) {
    var index
    index = text.indexOf("//")
    if (index === -1) {
        return text.trim()
    } else {
        return text.substring(0, index).trim()
    }
}

function equal(varName, value) {
    return varName + " === " + value
}

function extractAssignment(build, diagram, item, expression) {
    var work
    if (expression.left.type === "Identifier") {
        if (isScenario(diagram)) {
            addItemError(
            	build,
            	diagram,
            	item.id,
            	"BUILD_NO_VAR_SCEN"
            )
        } else {
            work = diagram.work
            work.assigned[expression.left.name] = true
        }
    }
}

function extractDeclarators(build, diagram, item, statement) {
    var forbidVar, work
    var _sw20130000_ = 0;
    work = diagram.work
    forbidVar = work.branches.length > 1
    if (isScenario(diagram)) {
        addItemError(
        	build,
        	diagram,
        	item.id,
        	"BUILD_NO_VAR_SCEN"
        )
    } else {
        _sw20130000_ = statement.kind;
        if (_sw20130000_ === "var") {
            if ((forbidVar) || (globalForbidVar)) {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_NO_VAR"
                )
            } else {
                var _ind525 = 0;
                var _col525 = statement.declarations;
                var _len525 = _col525.length;
                while (true) {
                    if (_ind525 < _len525) {
                        
                    } else {
                        break;
                    }
                    var dec = _col525[_ind525];
                    if (((dec.type === "VariableDeclarator") && (dec.id)) && (dec.id.name)) {
                        work.declared[dec.id.name] = true
                    }
                    _ind525++;
                }
            }
        } else {
            if (_sw20130000_ === "const") {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_NO_CONST"
                )
            } else {
                if (_sw20130000_ === "let") {
                    addItemError(
                    	build,
                    	diagram,
                    	item.id,
                    	"BUILD_NO_LET"
                    )
                } else {
                    addItemError(
                    	build,
                    	diagram,
                    	item.id,
                    	"BUILD_BAD_DECLARATION"
                    )
                }
            }
        }
    }
}

function filterLoopLoops(map) {
    var result
    result = {}
    var _ind1847 = 0;
    var _col1847 = map;
    var _keys1847 = Object.keys(_col1847); 
    var _len1847 = _keys1847.length;
    while (true) {
        if (_ind1847 < _len1847) {
            
        } else {
            break;
        }
        var id = _keys1847[_ind1847]; var item = _col1847[id];
        if (item.type === "arrow-loop") {
            result[id] = Object.keys(item.loops).length
        }
        _ind1847++;
    }
    return result
}

function findBlockEnds(prev, item, paths, context) {
    var p2
    var _sw9190000_ = 0;
    Object.freeze(paths)
    if (item) {
        if (isArrow(prev, item)) {
            item.adangling = paths.concat(
                item.adangling
            )
            item.aclosing++
            if (item.aclosing === item.aprev.length) {
                completeLoop(
                    item,
                    context
                )
            }
        } else {
            if (isHierarchyBroken(prev, item)) {
                countAsExit(
                    prev,
                    context,
                    paths
                )
                addBroken(prev, item)
                addDiagramError(
                    context.build,
                    context.diagram,
                    globals.strings.BUILD_EXIT_FROM_NESTED
                )
            }
            item.dangling = paths.concat(
                item.dangling
            )
            item.closing++
            if (item.closing === item.prev.length) {
                buildEnds(
                    item,
                    context
                )
                p2 = item.dangling
                _sw9190000_ = item.type;
                if (_sw9190000_ === "question") {
                    var _ind959 = 0;
                    var _col959 = p2;
                    var _len959 = _col959.length;
                    while (true) {
                        if (_ind959 < _len959) {
                            
                        } else {
                            break;
                        }
                        var id = _col959[_ind959];
                        context.subtrees[id]++
                        _ind959++;
                    }
                    p2 = pushBack(p2, item.id)
                    context.subtrees[item.id] = 1
                } else {
                    if (_sw9190000_ === "arrow-loop") {
                        p2 = pushBack(p2, item.id)
                        context.subtrees[item.id] = 0
                    }
                }
                findBlockEnds(
                    item,
                    item.two,
                    p2,
                    context
                )
                findBlockEnds(
                    item,
                    item.one,
                    p2,
                    context
                )
            }
        }
    }
}

function findBreakouts(work) {
    var _ind1928 = 0;
    var _col1928 = work.items;
    var _keys1928 = Object.keys(_col1928); 
    var _len1928 = _keys1928.length;
    while (true) {
        if (_ind1928 < _len1928) {
            
        } else {
            break;
        }
        var id = _keys1928[_ind1928]; var item = _col1928[id];
        if ((item.parentLoop) && (!(item.type === "arrow-loop"))) {
            tryBreakout(item, item.one)
            tryBreakout(item, item.two)
        }
        _ind1928++;
    }
}

function findEnd(node) {
    var count
    var _sw15290000_ = 0;
    count = 0
    while (true) {
        _sw15290000_ = node.type;
        if (_sw15290000_ === "loopbegin") {
            count++
        } else {
            if (_sw15290000_ === "loopend") {
                count--
            }
        }
        if (count === 0) {
            break;
        }
        node = node.one
    }
    return node
}

function findParentLoops(work) {
    var hierarchy, map
    map = createItemsMap(work)
    bindItemsToLoops(
        work,
        map
    )
    hierarchy = filterLoopLoops(map)
    setClosestParentLoops(
        work,
        map,
        hierarchy
    )
}

function findVariables(build, diagram, item, statements) {
    var _sw23480000_ = 0;
    var _ind2345 = 0;
    var _col2345 = statements;
    var _len2345 = _col2345.length;
    while (true) {
        if (_ind2345 < _len2345) {
            
        } else {
            break;
        }
        var statement = _col2345[_ind2345];
        _sw23480000_ = statement.type;
        if (_sw23480000_ === "VariableDeclaration") {
            extractDeclarators(
                build,
                diagram,
                item,
                statement
            )
        } else {
            if (_sw23480000_ === "ExpressionStatement") {
                if (statement.expression.type === "AssignmentExpression") {
                    extractAssignment(
                        build,
                        diagram,
                        item,
                        statement.expression
                    )
                }
            } else {
                if (_sw23480000_ === "TryStatement") {
                    findVariables(
                        build,
                        diagram,
                        item,
                        statement.block.body
                    )
                    if ((statement.handler) && (statement.handler.body.body)) {
                        findVariables(
                            build,
                            diagram,
                            item,
                            statement.handler.body.body
                        )
                    }
                }
            }
        }
        _ind2345++;
    }
}

function getBody(item) {
    return item.script.body[0].body.body
}

function getBranchById(machine, branchId) {
    var _ind2948 = 0;
    var _col2948 = machine.diagram.work.branches;
    var _len2948 = _col2948.length;
    while (true) {
        if (_ind2948 < _len2948) {
            
        } else {
            throw new Error("Branch not found: " + branchId)
        }
        var branch = _col2948[_ind2948];
        if (branch.branchId === branchId) {
            return branch.item
        }
        _ind2948++;
    }
}

function getCreateArray(dict, key) {
    var array
    if (key in dict) {
        return dict[key]
    } else {
        array = []
        dict[key] = array
        return array
    }
}

function getCurrentLoop(context, loops) {
    var id
    id = loops[loops.length - 1]
    if (id) {
        return context.items[id]
    } else {
        return undefined
    }
}

function getExported(build) {
    var isExported
    isExported = function(diagram) {
        return "export" in diagram.output.flags
    }
    return build.diagrams.filter(isExported)
}

function getLast(array) {
    return array[array.length - 1]
}

function getOneBroken(item, broken) {
    if ((broken) || (item.oneBroken)) {
        return true
    } else {
        return false
    }
}

function getParentLoop(id, map, hierarchy) {
    var byCount, loops, loopsIds
    loops = map[id].loops
    byCount = function(loopId) {
        return hierarchy[loopId]
    }
    loopsIds = Object.keys(loops)
    return _.maxBy(loopsIds, byCount)
}

function getSelectVar(item) {
    var varName
    varName = "_sw_" + item.id
    return varName
}

function getTwoBroken(item, broken) {
    if ((broken) || (item.twoBroken)) {
        return true
    } else {
        return false
    }
}

function hasReturn(seq) {
    var body, item, last
    if (seq.items.length === 0) {
        return false
    } else {
        item = seq.items[seq.items.length - 1]
        if (item.script) {
            body = getBody(item)
            if (body.length === 0) {
                return false
            } else {
                last = body[body.length - 1]
                if ((last.type === "ReturnStatement") || (last.type === "ThrowStatement")) {
                    return true
                } else {
                    return false
                }
            }
        } else {
            return false
        }
    }
}

function init() {
    globals.strings = createStrings()
}

function insertAfter(work, before, id, type, two) {
    var item, next
    if (two) {
        next = before.two
    } else {
        next = before.one
    }
    item = createItem(
        work,
        id,
        type,
        ""
    )
    if (isArrow(before, next)) {
        next.aprev = _.pull(next.aprev, before)
        next.aprev.push(item)
    } else {
        next.prev = _.pull(next.prev, before)
        next.prev.push(item)
    }
    if (two) {
        before.two = item
    } else {
        before.one = item
    }
    item.one = next
    item.prev.push(before)
    return item
}

function isArrow(before, after) {
    if (((after) && (after.type == "arrow-loop")) && (_.includes(after.aprev, before))) {
        return true
    } else {
        return false
    }
}

function isBefore(before, node) {
    while (true) {
        if (node === before) {
            return true
        }
        if (node.prev.length === 0) {
            return false
        }
        node = node.prev[0]
    }
}

function isHierarchyBroken(prev, next) {
    if (((prev.type === "arrow-loop") || (prev.parentLoop == next.parentLoop)) || ((prev.parentLoop) && (prev.parentLoop.parentLoop === next.parentLoop))) {
        return false
    } else {
        return true
    }
}

function isLoop(context, id) {
    var item
    item = context.items[id]
    return item.type === "arrow-loop"
}

function isScenario(diagram) {
    var result
    if (diagram.work.flags["scenario"]) {
        result = true
    } else {
        result = false
    }
    return result
}

function ln(output, line) {
    output.push(line)
}

function makeId(diagram) {
    return diagram.space_id + " " +
    	diagram.id
}

function makeIndent(depth) {
    return _.repeat(INDENT, depth)
}

function normalizeQuestions(work) {
    var tmp
    var _ind252 = 0;
    var _col252 = work.items;
    var _keys252 = Object.keys(_col252); 
    var _len252 = _keys252.length;
    while (true) {
        if (_ind252 < _len252) {
            
        } else {
            break;
        }
        var id = _keys252[_ind252]; var item = _col252[id];
        if ((item.type === "question") && (!(item.flag1))) {
            tmp = item.one
            item.one = item.two
            item.two = tmp
            item.flag1 = 1
        }
        _ind252++;
    }
}

function not(value) {
    return "!(" + value + ")"
}

function notEmpty(text) {
    return text.length > 0
}

function or(left, right) {
    return "(" + left + ") || (" +
      right + ")"
}

function parseAction(build, diagram, item) {
    var script, work, wrapped
    work = diagram.work
    if (item.text) {
        wrapped = "async function foo() {" +
        	item.text + "}"
        try {
        	script = esprima.parseScript(
        		wrapped
        	)
        } catch (e) {
        	addItemError(
        		build,
        		diagram,
        		item.id,
        		e.description
        	)
        	return
        }
        item.script = script
        findVariables(
            build,
            diagram,
            item,
            getBody(item)
        )
    }
}

function parseForLoop(build, diagram, item, one) {
    var semi1, semi2, text, varName, work
    var _sw8110000_ = 0;
    work = diagram.work
    _sw8110000_ = one.type;
    if (_sw8110000_ === "VariableDeclaration") {
        varName = one.declarations[0].id.name
        work.declared[varName] = true
        text = item.text
        semi1 = text.indexOf(";")
        if (semi1 === -1) {
            addItemError(
            	build,
            	diagram,
            	item.id,
            	"BUILD_BAD_LOOP"
            )
        } else {
            semi2 = text.indexOf(
                ";",
                semi1 + 1
            )
            if (semi2 === -2) {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_BAD_LOOP"
                )
            } else {
                item.loopInfo = {
                    type : "for",
                    one : text.substring(0, semi1).trim(),
                    two : text.substring(semi1 + 1, semi2).trim(),
                    three : text.substring(semi2 + 1).trim()
                }
            }
        }
    } else {
        if (((_sw8110000_ === "ExpressionStatement") && (one.expression.type == "AssignmentExpression")) && (one.expression.left.type == "Identifier")) {
            varName = one.expression.left.name
            work.assigned[varName] = true
            text = item.text
            semi1 = text.indexOf(";")
            if (semi1 === -1) {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_BAD_LOOP"
                )
            } else {
                semi2 = text.indexOf(
                    ";",
                    semi1 + 1
                )
                if (semi2 === -2) {
                    addItemError(
                    	build,
                    	diagram,
                    	item.id,
                    	"BUILD_BAD_LOOP"
                    )
                } else {
                    item.loopInfo = {
                        type : "for",
                        one : text.substring(0, semi1).trim(),
                        two : text.substring(semi1 + 1, semi2).trim(),
                        three : text.substring(semi2 + 1).trim()
                    }
                }
            }
        } else {
            addItemError(
            	build,
            	diagram,
            	item.id,
            	"BUILD_BAD_LOOP"
            )
        }
    }
}

function parseForeachLoop(build, diagram, item, it, collection) {
    var exp, exp1, exp2, key, loopInfo, message, semiIndex, value
    var _sw7540000_ = 0;
    if ((it.type === "ExpressionStatement") && (collection.type === "ExpressionStatement")) {
        exp = it.expression
        _sw7540000_ = exp.type;
        if (_sw7540000_ === "Identifier") {
            key = undefined
            value = it.expression.name
            semiIndex = item.text.indexOf(";")
            if (semiIndex === -1) {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_BAD_LOOP"
                )
            } else {
                if ((key) && (!(registerVarLoop(diagram, key)))) {
                    message = translate(
                        build,
                        "BUILD_BAD_LOOP_VARIABLE"
                    )
                    addItemError(
                    	build,
                    	diagram,
                    	item.id,
                    	message + ": " + key
                    )
                } else {
                    if (registerVarLoop(diagram, value)) {
                        loopInfo = {
                            type : "foreach",
                            key : key,
                            value : value
                        }
                        loopInfo.collection = item.text.substring(
                        	semiIndex + 1
                        ).trim()
                        item.loopInfo = loopInfo
                    } else {
                        message = translate(
                            build,
                            "BUILD_BAD_LOOP_VARIABLE"
                        )
                        addItemError(
                        	build,
                        	diagram,
                        	item.id,
                        	message + ": " + value
                        )
                    }
                }
            }
        } else {
            if ((_sw7540000_ === "SequenceExpression") && (exp.expressions.length === 2)) {
                exp1 = exp.expressions[0]
                exp2 = exp.expressions[1]
                if ((exp1.type === "Identifier") && (exp2.type === "Identifier")) {
                    key = exp1.name
                    value = exp2.name
                    semiIndex = item.text.indexOf(";")
                    if (semiIndex === -1) {
                        addItemError(
                        	build,
                        	diagram,
                        	item.id,
                        	"BUILD_BAD_LOOP"
                        )
                    } else {
                        if ((key) && (!(registerVarLoop(diagram, key)))) {
                            message = translate(
                                build,
                                "BUILD_BAD_LOOP_VARIABLE"
                            )
                            addItemError(
                            	build,
                            	diagram,
                            	item.id,
                            	message + ": " + key
                            )
                        } else {
                            if (registerVarLoop(diagram, value)) {
                                loopInfo = {
                                    type : "foreach",
                                    key : key,
                                    value : value
                                }
                                loopInfo.collection = item.text.substring(
                                	semiIndex + 1
                                ).trim()
                                item.loopInfo = loopInfo
                            } else {
                                message = translate(
                                    build,
                                    "BUILD_BAD_LOOP_VARIABLE"
                                )
                                addItemError(
                                	build,
                                	diagram,
                                	item.id,
                                	message + ": " + value
                                )
                            }
                        }
                    }
                } else {
                    addItemError(
                    	build,
                    	diagram,
                    	item.id,
                    	"BUILD_BAD_LOOP"
                    )
                }
            } else {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_BAD_LOOP"
                )
            }
        }
    } else {
        addItemError(
        	build,
        	diagram,
        	item.id,
        	"BUILD_BAD_LOOP"
        )
    }
}

function parseItems(build, diagram) {
    var work
    var _sw4710000_ = 0;
    work = diagram.work
    work.assigned = {}
    work.declared = {}
    work.loopVars = {}
    parseParams(
        build,
        diagram
    )
    rewireSelects(build, diagram)
    var _ind468 = 0;
    var _col468 = work.items;
    var _keys468 = Object.keys(_col468); 
    var _len468 = _keys468.length;
    while (true) {
        if (_ind468 < _len468) {
            
        } else {
            break;
        }
        var id = _keys468[_ind468]; var item = _col468[id];
        _sw4710000_ = item.type;
        if ((_sw4710000_ === "action") || (_sw4710000_ === "insertion")) {
            parseAction(
                build,
                diagram,
                item
            )
        } else {
            if (_sw4710000_ === "question") {
                parseQuestion(
                    build,
                    diagram,
                    item
                )
            }
        }
        _ind468++;
    }
    var _ind594 = 0;
    var _col594 = work.items;
    var _keys594 = Object.keys(_col594); 
    var _len594 = _keys594.length;
    while (true) {
        if (_ind594 < _len594) {
            
        } else {
            break;
        }
        var id = _keys594[_ind594]; var item = _col594[id];
        if (item.type === "loopbegin") {
            parseLoop(
                build,
                diagram,
                item
            )
        }
        _ind594++;
    }
    var _ind1449 = 0;
    var _col1449 = work.items;
    var _keys1449 = Object.keys(_col1449); 
    var _len1449 = _keys1449.length;
    while (true) {
        if (_ind1449 < _len1449) {
            
        } else {
            break;
        }
        var id = _keys1449[_ind1449]; var item = _col1449[id];
        if ((item.type === "loopbegin") && (item.loopInfo)) {
            if (item.loopInfo.type == "foreach") {
                if (item.loopInfo.key) {
                    rewireForeachMap(
                        diagram,
                        item
                    )
                } else {
                    rewireForeachArray(
                        diagram,
                        item
                    )
                }
            } else {
                rewireFor(
                    diagram,
                    item
                )
            }
        }
        _ind1449++;
    }
    var _ind1690 = 0;
    var _col1690 = work.items;
    var _keys1690 = Object.keys(_col1690); 
    var _len1690 = _keys1690.length;
    while (true) {
        if (_ind1690 < _len1690) {
            
        } else {
            break;
        }
        var id = _keys1690[_ind1690]; var item = _col1690[id];
        if (item.type === "arrow-loop") {
            addFakeLoopEnd(
                diagram,
                item
            )
        }
        _ind1690++;
    }
    buildVariableList(work)
}

function parseLoop(build, diagram, item) {
    var text
    var _sw7050000_ = 0;
    text = (item.text || "").trim()
    if (text) {
        var script
        try {
        	script = esprima.parseScript(
        		text
        	)
        } catch (e) {
        	addItemError(
        		build,
        		diagram,
        		item.id,
        		e.description
        	)
        	return
        }
        _sw7050000_ = script.body.length;
        if (_sw7050000_ === 2) {
            parseForeachLoop(
                build,
                diagram,
                item,
                script.body[0],
                script.body[1]
            )
        } else {
            if (_sw7050000_ === 3) {
                parseForLoop(
                    build,
                    diagram,
                    item,
                    script.body[0]
                )
            } else {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_BAD_LOOP"
                )
            }
        }
    } else {
        addItemError(
        	build,
        	diagram,
        	item.id,
        	"BUILD_EXPRESSION_EXPECTED"
        )
    }
}

function parseParamLine(line) {
    var noComment, parts, trimmed
    noComment = cutOffComment(line)
    parts = noComment.split(" ")
    trimmed = parts.map(
    	function(part) {
    		return part.trim()
    	}
    )
    return trimmed.filter(
        notEmpty
    )
}

function parseParams(build, diagram) {
    var allElements, allowed, arg, elements, keywords, lines, params, used, work
    work = diagram.work
    work.flags = {}
    work.args = []
    params = work.params || ""
    keywords = work.keywords || {}
    lines = params.split("\n")
    allElements = lines.map(
        parseParamLine
    )
    elements = allElements.filter(
        notEmpty
    )
    allowed = [
    	"async",
    	"default",
    	"export",
    	"scenario"
    ]
    used = []
    var _ind2368 = 0;
    var _col2368 = allowed;
    var _len2368 = _col2368.length;
    while (true) {
        if (_ind2368 < _len2368) {
            
        } else {
            break;
        }
        var key = _col2368[_ind2368];
        if (keywords[key]) {
            used.push(key)
        }
        _ind2368++;
    }
    var _ind690 = 0;
    var _col690 = used;
    var _len690 = _col690.length;
    while (true) {
        if (_ind690 < _len690) {
            
        } else {
            break;
        }
        var key = _col690[_ind690];
        work.flags[key] = true
        _ind690++;
    }
    var _ind686 = 0;
    var _col686 = elements;
    var _len686 = _col686.length;
    while (true) {
        if (_ind686 < _len686) {
            
        } else {
            break;
        }
        var element = _col686[_ind686];
        arg = element.join(" ")
        work.args.push(arg)
        work.declared[arg] = true
        _ind686++;
    }
}

function parseQuestion(build, diagram, item) {
    var st, text
    text = (item.text || "").trim()
    if (text) {
        var script
        try {
        	script = esprima.parseScript(
        		text
        	)
        } catch (e) {
        	addItemError(
        		build,
        		diagram,
        		item.id,
        		e.description
        	)
        	return
        }
        if (script.body.length > 1) {
            addItemError(
            	build,
            	diagram,
            	item.id,
            	"BUILD_ONE_EXPRESSION_EXPECTED"
            )
        } else {
            st = script.body[0]
            if ((st.type === "ExpressionStatement") && (st.expression.type === "AssignmentExpression")) {
                addItemError(
                	build,
                	diagram,
                	item.id,
                	"BUILD_ASSIGNMENT_NOT_ALLOWED"
                )
            }
        }
    } else {
        addItemError(
        	build,
        	diagram,
        	item.id,
        	"BUILD_EXPRESSION_EXPECTED"
        )
    }
}

function parseReceiveCase(text) {
    var arg, close, fun, open
    text = text || ""
    text = text.trim()
    if (text) {
        open = text.indexOf("(")
        close = text.indexOf(")")
        if ((open <= 0) || (!(close === text.length - 1))) {
            return undefined
        } else {
            fun = text.substring(0, open)
            arg = text.substring(
                open + 1,
                close
            )
            if ((arg.indexOf(".") === -1) && (fun.indexOf(".") === -1)) {
                return {
                    functionName : fun,
                    argName : arg
                }
            } else {
                return undefined
            }
        }
    } else {
        return undefined
    }
}

function prepareDiagram(build, diagram) {
    var branch, copy, input, visited, work
    var _sw750000_ = 0;
    diagram.work = {
        items : {},
        branches : [],
        params : diagram.params,
        keywords : diagram.keywords,
        nextId : 1
    }
    input = diagram.input
    work = diagram.work
    var _ind71 = 0;
    var _col71 = input.items;
    var _len71 = _col71.length;
    while (true) {
        if (_ind71 < _len71) {
            
        } else {
            break;
        }
        var item = _col71[_ind71];
        copy = copyItem(item)
        _sw750000_ = copy.type;
        if (_sw750000_ === "branch") {
            branch = {
                item : copy,
                branchId : copy.branchId,
                uses : 0
            }
            work.branches.push(branch)
        }
        work.items[copy.id] = copy
        _ind71++;
    }
    work.branches = _.sortBy(
        work.branches,
        "branchId"
    )
    var _ind95 = 0;
    var _col95 = work.branches;
    var _len95 = _col95.length;
    while (true) {
        if (_ind95 < _len95) {
            
        } else {
            break;
        }
        var branch = _col95[_ind95];
        visited = {}
        connectItem(
            work,
            branch.item,
            visited
        )
        _ind95++;
    }
    parseItems(build, diagram)
    while (true) {
        if (shortCircuit(work)) {
            
        } else {
            break;
        }
    }
    //normalizeQuestions(work)
}

function printBreak(node, depth, output) {
    var indent
    indent = makeIndent(depth)
    ln(output, indent + "break;")
}

function printDiagram(build, diagram) {
    printNode(
        diagram.work.fun,
        0,
        build.lines
    )
}

function printFunction(node, depth, output) {
    var header, indent, keywords
    indent = makeIndent(depth)
    keywords = ""
    keywords = addFlag(node, "export", keywords)
    keywords = addFlag(node, "default", keywords)
    keywords = addFlag(node, "async", keywords)
    header = indent + keywords + "function " +
    	node.name + "(" + node.args.join(", ") +
    	") {"
    ln(output, header)
    printSeq(
        node.body,
        depth + 1,
        output
    )
    ln(output, indent + "}")
    ln(output, "")
}

function printIds(items, prop) {
    var content, getId
    getId = function(item) {
        return item.id
    }
    content = items.map(getId).join(",")
    if (content) {
        return " " + prop + ":" + content
    } else {
        return ""
    }
}

function printIf(node, depth, output) {
    var alt, header, indent, then
    indent = makeIndent(depth)
    header = indent + "if (" + node.condition  +
    	") {"
    ln(output, header)
    if (node.flag1) {
        then = node.down
        alt = node.right
    } else {
        then = node.right
        alt = node.down
    }
    printSeq(
        then,
        depth + 1,
        output
    )
    if (alt.items.length === 0) {
        
    } else {
        ln(output, indent + "} else {")
        printSeq(
            alt,
            depth + 1,
            output
        )
    }
    ln(output, indent + "}")
}

function printNode(node, depth, output) {
    node.print(
        node,
        depth,
        output
    )
}

function printPrepared(build, diagram) {
    var indent, line, work
    work = diagram.work
    indent = "    "
    build.lines.push("/*")
    build.lines.push(diagram.name)
    if (diagram.work.declared) {
        build.lines.push(
        	indent + "declared: " + 
        	Object.keys(work.declared).join(",")
        )
    }
    if (diagram.work.assigned) {
        build.lines.push(
        	indent + "assigned: " + 
        	Object.keys(work.assigned).join(",")
        )
    }
    build.lines.push(
    	indent + "vars: " + work.vars.join(",")
    )
    build.lines.push(
    	indent + "args: " + work.args.join(",")
    )
    build.lines.push(
    	indent + "flags: " + Object.keys(work.flags).join(",")
    )
    if (work.params) {
        build.lines.push(
        	indent + "params: " + zapNewLines(work.params)
        )
    }
    var _ind336 = 0;
    var _col336 = work.items;
    var _keys336 = Object.keys(_col336); 
    var _len336 = _keys336.length;
    while (true) {
        if (_ind336 < _len336) {
            
        } else {
            break;
        }
        var id = _keys336[_ind336]; var item = _col336[id];
        line = indent + item.id + " " +
        	item.type + " " +
        	zapNewLines(item.text) + " "
        if (item.one) {
            line += " one:" + item.one.id
            if (item.two) {
                line += " two:" + item.two.id
            }
        }
        line += printIds(item.prev, "prev")
        line += printIds(item.aprev, "aprev")
        if (item.ends.length > 0) {
            line += " ends: " + item.ends.join(",")
        }
        build.lines.push(line)
        _ind336++;
    }
    build.lines.push("*/")
    build.lines.push("")
}

function printPrim(node, depth, output) {
    var indent, lines
    if (node.text) {
        indent = makeIndent(depth)
        lines = node.text.split("\n")
        var _ind1155 = 0;
        var _col1155 = lines;
        var _len1155 = _col1155.length;
        while (true) {
            if (_ind1155 < _len1155) {
                
            } else {
                break;
            }
            var line = _col1155[_ind1155];
            ln(output, indent + line)
            _ind1155++;
        }
    }
}

function printSeq(node, depth, output) {
    var indent
    indent = makeIndent(depth)
    var _ind1123 = 0;
    var _col1123 = node.items;
    var _len1123 = _col1123.length;
    while (true) {
        if (_ind1123 < _len1123) {
            
        } else {
            break;
        }
        var step = _col1123[_ind1123];
        printNode(
            step,
            depth,
            output
        )
        _ind1123++;
    }
}

function printSwitch(node, depth, output) {
    var header, i1, i2, indent
    indent = makeIndent(depth)
    header = indent + "switch (" + node.condition  +
    	") {"
    ln(output, header)
    i1 = makeIndent(depth + 1)
    i2 = makeIndent(depth + 2)
    var _ind2754 = 0;
    var _col2754 = node.cases;
    var _len2754 = _col2754.length;
    while (true) {
        if (_ind2754 < _len2754) {
            
        } else {
            break;
        }
        var caseItem = _col2754[_ind2754];
        ln(output, i1 + "case \"" +
          caseItem.value + "\":")
        printSeq(
            caseItem.seq,
            depth + 2,
            output
        )
        ln(output, i2 + "break;")
        _ind2754++;
    }
    if (node.defReturn) {
        ln(output, i1 + "default:")
        ln(output, i2 + "return;")
    }
    ln(output, indent + "}")
}

function printWhile(node, depth, output) {
    var header, indent
    indent = makeIndent(depth)
    header = indent + "while (" + 
      node.condition + ") {"
    ln(output, header)
    printSeq(
        node.body,
        depth + 1,
        output
    )
    ln(output, indent + "}")
}

function processDiagram(build, diagram) {
    prepareDiagram(build, diagram)
    if (isScenario(diagram)) {
        buildScenario(build, diagram)
    } else {
        buildBody(build, diagram)
        //printPrepared(build, diagram)
        printDiagram(build, diagram)
    }
    diagram.work = undefined
}

function pushBack(array, item) {
    return array.concat([item])
}

function registerVarLoop(diagram, varName) {
    var work
    work = diagram.work
    if (varName in work.loopVars) {
        return true
    } else {
        if (varName in work.declared) {
            return false
        } else {
            if (varName in work.assigned) {
                return false
            } else {
                work.loopVars[varName] = true
                work.assigned[varName] = true
                return true
            }
        }
    }
}

function removeFromPrev(next, prev) {
    next.prev = _.pull(next.prev, prev)
}

function replaceAddresses(diagram) {
    
}

function replaceOne(item) {
    var one, two, victim
    victim = item.one
    one = victim.one
    two = victim.two
    one.prev = _.pull(one.prev, victim)
    one.prev.push(item)
    item.one = one
    if (_.includes(two.aprev, victim)) {
        two.aprev = _.pull(two.aprev, victim)
    } else {
        two.prev = _.pull(two.prev, victim)
    }
}

function replacePrev(item, oldPrev, newPrev) {
    if (_.includes(item.prev, oldPrev)) {
        item.prev = _.pull(item.prev, oldPrev)
        item.prev.push(newPrev)
    } else {
        item.aprev = _.pull(item.aprev, oldPrev)
        item.aprev.push(newPrev)
    }
}

function replaceTwo(item) {
    var one, two, victim
    victim = item.two
    one = victim.one
    two = victim.two
    one.prev = _.pull(one.prev, victim)
    item.two = two
    if (_.includes(two.aprev, victim)) {
        two.aprev = _.pull(two.aprev, victim)
        two.aprev.push(item)
    } else {
        two.prev = _.pull(two.prev, victim)
        two.prev.push(item)
    }
}

function rewireAnd(work, item) {
    var left, right, victim
    victim = item.one
    left = item.text
    right = victim.text
    if (item.flag1) {
        if (victim.flag1) {
            
        } else {
            right = not(right)
        }
        item.text = and(left, right)
        item.flag1 = 1
    } else {
        if (victim.flag1) {
            left = not(left)
            item.text = and(left, right)
            item.flag1 = 1
        } else {
            item.text = or(left, right)
            item.flag1 = 0
        }
    }
    replaceOne(item)
    delete work.items[victim.id]
}

function rewireCase(build, diagram, caseItem, varName) {
    var errorText, newItem, throwId
    if (caseItem.text) {
        caseItem.type = "question"
        caseItem.text = equal(varName, caseItem.text)
        caseItem.flag1 = 1
        if (caseItem.two) {
            return caseItem.two
        } else {
            throwId = "_err_" + caseItem.id
            errorText = switchError(varName)
            newItem = createItem(
                diagram.work,
                throwId,
                "action",
                errorText
            )
            addToSameTarget(
            	caseItem,
            	newItem
            )
            caseItem.two = newItem
            newItem.prev.push(caseItem)
            return undefined
        }
    } else {
        if (caseItem.two) {
            addItemError(
                build,
                diagram,
                caseItem.id,
                "BUILD_EMPTY_CASE_NOT_LAST"
            )
        } else {
            caseItem.type = "action"
        }
        return undefined
    }
}

function rewireFor(diagram, item) {
    var loop, texts
    loop = item.loopInfo
    texts = {}
    texts.init = loop.one + ";"
    texts.check = loop.two
    texts.values = ""
    texts.increment = loop.three + ";"
    rewireLoopCore(
        diagram,
        item,
        texts
    )
}

function rewireForeachArray(diagram, item) {
    var col, it, length, loop, text, texts, work
    loop = item.loopInfo
    work = diagram.work
    texts = {}
    it = "_" + item.id + "_it"
    col = "_" + item.id + "_col"
    length = "_" + item.id + "_length"
    if (isScenario(diagram)) {
        it = "self." + it
        col = "self." + col
        length = "self." + length
        loop.value = "self." + loop.value
    } else {
        work.assigned[it] = true
        work.assigned[col] = true
        work.assigned[length] = true
    }
    text = assign(it, "0") + "\n"
    text += assign(col, loop.collection) + "\n"
    text += assign(length, col + ".length")
    texts.init = text
    texts.check = it + " < " + length
    texts.values = assign(loop.value, col + "[" + it + "]")
    texts.increment = it + "++;"
    rewireLoopCore(
        diagram,
        item,
        texts
    )
}

function rewireForeachMap(diagram, item) {
    var col, it, keys, length, loop, text, texts, work
    loop = item.loopInfo
    work = diagram.work
    texts = {}
    it = "_" + item.id + "_it"
    col = "_" + item.id + "_col"
    length = "_" + item.id + "_length"
    keys = "_" + item.id + "_keys"
    if (isScenario(diagram)) {
        it = "self." + it
        col = "self." + col
        length = "self." + length
        keys = "self." + keys
        loop.key = "self." + loop.key
        loop.value = "self." + loop.value
    } else {
        work.assigned[it] = true
        work.assigned[col] = true
        work.assigned[length] = true
        work.assigned[keys] = true
    }
    text = assign(it, "0") + "\n"
    text += assign(col, loop.collection) + "\n"
    text += assign(keys, "Object.keys(" + col + ")") + "\n"
    text += assign(length, keys + ".length")
    texts.init = text
    texts.check = it + " < " + length
    texts.values = assign(loop.key, keys + "[" + it + "]") + "\n"
    texts.values += assign(loop.value, col + "[" + loop.key + "]")
    texts.increment = it + "++;"
    rewireLoopCore(
        diagram,
        item,
        texts
    )
}

function rewireLoopCore(diagram, item, texts) {
    var arrowLoop, check, end, next, values, work
    work = diagram.work
    end = findEnd(item)
    next = end.one
    item.type = "action"
    item.text = texts.init
    arrowLoop = insertAfter(
        work,
        item,
        "_" + item.id + "_loop",
        "arrow-loop"
    )
    check = insertAfter(
        work,
        arrowLoop,
        "_" + item.id + "_check",
        "question"
    )
    check.text = texts.check
    check.two = check.one
    check.one = next
    replacePrev(next, end, check)
    values = insertAfter(
        work,
        check,
        "_" + item.id + "_values",
        "action",
        true
    )
    values.text = texts.values
    end.type = "action"
    end.text = texts.increment
    end.one = arrowLoop
    arrowLoop.aprev.push(end)
}

function rewireOr(work, item) {
    var left, right, victim
    victim = item.two
    left = item.text
    right = victim.text
    if (item.flag1) {
        if (victim.flag1) {
            
        } else {
            right = not(right)
        }
        item.text = or(left, right)
        item.flag1 = 1
    } else {
        if (victim.flag1) {
            left = not(left)
            item.text = or(left, right)
            item.flag1 = 1
        } else {
            item.text = and(left, right)
            item.flag1 = 0
        }
    }
    replaceTwo(item)
    delete work.items[victim.id]
}

function rewireSelect(build, diagram, item) {
    var caseItem, varName
    varName = getSelectVar(item)
    if (isScenario(diagram)) {
        varName = "self." + varName
    }
    item.text = assign(varName, item.text)
    item.type = "action"
    caseItem = item.one
    while (true) {
        caseItem = rewireCase(
            build,
            diagram,
            caseItem,
            varName
        )
        if (caseItem) {
            
        } else {
            break;
        }
    }
}

function rewireSelects(build, diagram) {
    var _ind359 = 0;
    var _col359 = diagram.work.items;
    var _keys359 = Object.keys(_col359); 
    var _len359 = _keys359.length;
    while (true) {
        if (_ind359 < _len359) {
            
        } else {
            break;
        }
        var id = _keys359[_ind359]; var item = _col359[id];
        if ((item.type === "select") && (!((isScenario(diagram)) && (item.text === "receive")))) {
            rewireSelect(build, diagram, item)
        }
        _ind359++;
    }
}

function runName(diagram) {
    return diagram.name + "_run"
}

function scanIf(seq, item, loop, broken) {
    var last1, last2, next, step
    step = createIf(
        item.text,
        item.flag1
    )
    seq.items.push(step)
    next = scanSequence(
        step.down,
        item,
        item.one,
        item.id,
        loop,
        getOneBroken(item, broken)
    )
    scanSequence(
        step.right,
        item,
        item.two,
        item.id,
        loop,
        getTwoBroken(item, broken)
    )
    last1 = getLast(step.down.items)
    last2 = getLast(step.right.items)
    if ((((((last1) && (last2)) && (last1.type === last2.type)) && (last1.text === last2.text)) && (!(last1.type === "if"))) && (!(last1.type === "while"))) {
        step.down.items.pop()
        step.right.items.pop()
        seq.items.push(last1)
    }
    return next
}

function scanLoop(seq, item, broken) {
    var next, step
    step = createWhile()
    seq.items.push(step)
    next = scanSequence(
        step.body,
        item,
        item.one,
        item.id,
        item,
        getOneBroken(item, broken)
    )
    return next
}

function scanSequence(seq, prev, item, finish, loop, broken) {
    var breakOut, step
    var _sw23780000_ = 0;
    while (true) {
        if (item) {
            
        } else {
            break;
        }
        if (((item.type === "end") && (broken)) && (!(hasReturn(seq)))) {
            step = createReturn()
            seq.items.push(step)
            return undefined
        }
        if (_.includes(item.ends, finish)) {
            breakOut = addBreak(
                seq,
                prev,
                item,
                loop
            )
            if (breakOut) {
                
            } else {
                break;
            }
        }
        prev = item
        _sw23780000_ = item.type;
        if (_sw23780000_ === "end") {
            item = undefined
            break;
        }
        if (_sw23780000_ === "address") {
            addAddress(
                seq,
                item
            )
            item = undefined
            break;
        }
        if (_sw23780000_ === "question") {
            item = scanIf(
                seq,
                item,
                loop,
                broken
            )
        } else {
            if (_sw23780000_ === "arrow-loop") {
                item = scanLoop(
                    seq,
                    item,
                    broken
                )
            } else {
                step = createPrim(item.text)
                step.script = item.script
                seq.items.push(step)
                if (isArrow(item, item.one)) {
                    break;
                }
                item = item.one
            }
        }
    }
    return item
}

function setClosestParentLoops(work, map, hierarchy) {
    var parentId
    var _ind1886 = 0;
    var _col1886 = work.items;
    var _keys1886 = Object.keys(_col1886); 
    var _len1886 = _keys1886.length;
    while (true) {
        if (_ind1886 < _len1886) {
            
        } else {
            break;
        }
        var id = _keys1886[_ind1886]; var item = _col1886[id];
        parentId = getParentLoop(id, map, hierarchy)
        if (parentId) {
            item.parentLoop = work.items[parentId]
        } else {
            item.parentLoop = undefined
        }
        _ind1886++;
    }
}

function shortCircuit(work) {
    var _ind163 = 0;
    var _col163 = work.items;
    var _keys163 = Object.keys(_col163); 
    var _len163 = _keys163.length;
    while (true) {
        if (_ind163 < _len163) {
            
        } else {
            return false
        }
        var id = _keys163[_ind163]; var item = _col163[id];
        if (item.type === "question") {
            if ((canShortCircuit(item.one)) && (item.two === item.one.two)) {
                rewireAnd(work, item)
                return true
            }
            if ((canShortCircuit(item.two)) && (item.one === item.two.one)) {
                rewireOr(work, item)
                return true
            }
        }
        _ind163++;
    }
}

function startsWithWord(text, word) {
    if ((_.startsWith(text, word + " ")) || (_.startsWith(text, word + "\t"))) {
        return true
    } else {
        return false
    }
}

function switchError(varName) {
    return "throw new Error(\"Unexpected Choice value: \" + " +
    	varName + ");"
}

function translate(build, textId) {
    if (textId in globals.strings) {
        return globals.strings[textId]
    } else {
        return textId
    }
}

function waitState(id) {
    return id + "_wait"
}

function writeBlock(build, name) {
    if (name in build.props) {
        build.lines.push(build.props[name])
        build.lines.push("")
    }
}

function zapNewLines(text) {
    text = text || ""
    return text.split("\n").join(" ")
}


init()

module.exports.beginBuild = beginBuild
module.exports.processDiagram = processDiagram
module.exports.completeBuild = completeBuild
