-- Autogenerated with DRAKON Editor 1.32
local table = table
local string = string
local pairs = pairs
local ipairs = ipairs
local type = type
local tostring = tostring
local tonumber = tonumber
local print = print
local math = math
local os = os

local global_cfg = global_cfg
local globs = globs

local vud = require("vud")
local ej = require("ej")

local clock = require("clock")
local log = require("log")
local digest = require("digest")
local fiber = require("fiber")
local utils = require("utils")
local fun = require("fun")
local lic = require("lic")
local json = require("json")
local fio = require("fio")

local utf8 = require("lua-utf8")


local search_yield = 0.005
local current_version = 20180619
local root_folder_id = "1"

local db = require(global_cfg.db)

local default_html = "<!DOCTYPE html>\n" ..
"<html lang=\"en\">\n" ..
"<head>\n" ..
"  <meta charset=\"utf-8\"/>\n" ..
"  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n" ..
"  <title>@name@</title>\n" ..
"</head>\n" ..
"<body>\n" ..
"  <h1>@name@</h1>\n" ..
"  <div id=\"main\"></div>\n" ..
"  <script src=\"/gen/@gentoken@/@name@.js\">\n" ..
"   </script>\n" ..
"  <script>\n" ..
"  </script>\n" ..
"</body>\n" ..
"</html>"

local default_html_es6 = "<!DOCTYPE html>\n" ..
"<html lang=\"en\">\n" ..
"<head>\n" ..
"  <meta charset=\"utf-8\"/>\n" ..
"  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n" ..
"  <title>@name@</title>\n" ..

"</head>\n" ..
"<body>\n" ..
"  <h1>@name@</h1>\n" ..
"  <div id=\"main\"></div>\n" ..
"  <script type=\"module\">\n" ..
"   import * as @name@ from \"/gen/@gentoken@/@name@.js\";\n" ..
"  </script>\n" ..
"</body>\n" ..
"</html>"

setfenv(1, {}) 

function access(data, grant, user_id, roles)
    -- item 1731
    local message = access_core(
    	data,
    	grant,
    	user_id,
    	roles
    )
    -- item 1732
    if message then
        -- item 1737
        return message
    else
        -- item 1736
        return nil
    end
end

function access_core(data, grant, user_id, roles)
    -- item 2101
    local count = 0
    -- item 1668
    local space_id = data.workspace
    -- item 1665
    local message = check_admin_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 1666
    if message then
        -- item 1657
        return message, count
    else
        -- item 2969
        db.begin()
        -- item 1685
        if grant then
            for _, uid in ipairs(data.users) do
                -- item 1897
                log_user_event(
                	user_id,
                	"grant",
                	{principal=uid, space=space_id, 
                	op=data.operation}
                )
                -- item 2970
                db.rights_insert(
                	space_id,
                	uid,
                	data.operation,
                	{}
                )
            end
        else
            for _, uid in ipairs(data.users) do
                -- item 1898
                log_user_event(
                	user_id,
                	"revoke",
                	{principal=uid, space=space_id, 
                	op=data.operation}
                )
                -- item 2971
                db.rights_delete(
                	space_id,
                	uid,
                	data.operation
                )
            end
        end
        -- item 3064
        local sdata = db.space_get(space_id)
        -- item 3018
        local rights = db.rights_get_by_space(
        	space_id
        )
        -- item 3020
        local admins = get_admins(rights)
        -- item 1714
        if #admins == 0 then
            -- item 1717
            message = "ERR_LAST_ADMIN"
            -- item 2972
            db.rollback()
            -- item 1657
            return message, count
        else
            -- item 2089
            if ((grant) and (not (roles.admin))) and (not (data.operation == "read")) then
                -- item 2083
                local max_users = get_max_users(sdata)
                local actual_users = get_actual_users(
                	rights
                )
                -- item 2084
                if actual_users > max_users then
                    -- item 2087
                    message = "ERR_USER_LIMIT"
                    count = actual_users
                    -- item 2972
                    db.rollback()
                    -- item 1657
                    return message, count
                else
                    -- item 2116
                    update_space_limits_core(
                    	space_id,
                    	admins
                    )
                    -- item 2973
                    db.commit()
                    -- item 1709
                    return nil
                end
            else
                -- item 2116
                update_space_limits_core(
                	space_id,
                	admins
                )
                -- item 2973
                db.commit()
                -- item 1709
                return nil
            end
        end
    end
end

function add_child(space_id, folder_id, child_id, user_id)
    -- item 401
    local fdata = db.folder_get(space_id, folder_id)
    -- item 497
    if is_folder(fdata) then
        -- item 3114
        db.folder_tree_upsert(
        	space_id,
        	child_id,
        	folder_id
        )
        -- item 501
        return nil
    else
        -- item 500
        return "ERR_NOT_FOLDER"
    end
end

function add_default_html(space_id, folder_id, user_id, roles, props)
    -- item 3542
    if props.language == "LANG_JS" then
        -- item 3545
        if props.html then
            -- item 3548
            content = utils.trim(props.html)
            -- item 3549
            if #content == 0 then
                -- item 3551
                local ok, gt = get_create_gentoken(
                	space_id,
                	user_id,
                	roles
                )
                -- item 3552
                if ok then
                    -- item 3550
                    local fdata = db.folder_get(
                    	space_id,
                    	folder_id
                    )
                    -- item 3553
                    props.html = make_default_html(
                    	fdata.name,
                    	props.mformat,
                    	gt.gentoken
                    )
                end
            end
        else
            -- item 3551
            local ok, gt = get_create_gentoken(
            	space_id,
            	user_id,
            	roles
            )
            -- item 3552
            if ok then
                -- item 3550
                local fdata = db.folder_get(
                	space_id,
                	folder_id
                )
                -- item 3553
                props.html = make_default_html(
                	fdata.name,
                	props.mformat,
                	gt.gentoken
                )
            end
        end
    end
end

function add_to_recent(space_id, folder_id, user_id)
    -- item 1470
    local data = {
    	when = clock.time()
    }
    -- item 1471
    db.recent_upsert(
    	space_id,
    	folder_id,
    	user_id,
    	data
    )
    -- item 1472
    local urecent = db.recent_get_by_user(user_id)
    -- item 1473
    if #urecent > global_cfg.max_recent then
        -- item 1476
        local compare_when = function(left, right)
        	local lwhen = left[4].when
        	local rwhen = right[4].when
        	return lwhen < rwhen
        end
        -- item 1477
        table.sort(urecent, compare_when)
        -- item 1478
        local n = #urecent - global_cfg.max_recent
        local redundant = fun.take_n(n, urecent)
        for i, red in fun.iter(redundant) do
            -- item 1479
            db.recent_delete(
            	red[1],
            	red[2],
            	red[3]
            )
        end
    end
end

function add_to_trash(space_id, folders)
    for _, folder_id in ipairs(folders) do
        -- item 3106
        db.trash_insert(space_id, folder_id)
    end
end

function add_tree_node(space_id, folder_id, fdata, depth, lines)
    -- item 1017
    if is_folder(fdata) then
        -- item 1010
        local me = {
        	space_id = space_id,
        	id = folder_id,
        	name = fdata.name,
        	depth = depth
        }
        -- item 1016
        table.insert(lines, me)
        -- item 1020
        local children = {}
        -- item 3141
        local kids = get_child_folders(
        	space_id,
        	folder_id
        )
        for _, child_id in ipairs(kids) do
            -- item 1023
            local child_data = db.folder_get(
            	space_id,
            	child_id
            )
            -- item 1034
            table.insert(
            	children,
            	{
            		id = child_id,
            		fdata = child_data
            	}
            )
        end
        -- item 1035
        table.sort(
        	children,
        	compare_fdata
        )
        -- item 1012
        local cdepth = depth + 1
        for _, child in ipairs(children) do
            -- item 1015
            add_tree_node(
            	space_id,
            	child.id,
            	child.fdata,
            	cdepth,
            	lines
            )
        end
    end
end

function build_copy_plan(space_id, folder_id, plan)
    -- item 2315
    fiber.yield()
    -- item 3139
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    -- item 2310
    plan[folder_id] = utils.list_to_set(
    	children
    )
    for _, child_id in ipairs(children) do
        -- item 2314
        build_copy_plan(
        	space_id,
        	child_id,
        	plan
        )
    end
end

function by_count(left, right)
    -- item 2881
    return left.count > right.count
end

function calculate_depth(space_id, folder_id)
    -- item 1375
    local depth = 0
    while true do
        -- item 1381
        depth = depth + 1
        -- item 1383
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 1377
        if folder_id then
            
        else
            break
        end
    end
    -- item 1376
    return depth
end

function can_edit_folder(space_id, folder_id, user_id, roles)
    -- item 650
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 651
    if message then
        -- item 665
        return false, message
    else
        -- item 653
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 654
        if fdata then
            -- item 691
            if fdata.deleted then
                -- item 693
                message = "ERR_NOT_FOUND"
                -- item 665
                return false, message
            else
                -- item 664
                return true, fdata
            end
        else
            -- item 656
            message = "ERR_NOT_FOUND"
            -- item 665
            return false, message
        end
    end
end

function check_admin_access(space_id, user_id, roles)
    -- item 1205
    local sdata = db.space_get(space_id)
    -- item 1206
    if sdata then
        -- item 1209
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	roles
        )
        -- item 1198
        if access == "admin" then
            -- item 1201
            return nil
        else
            -- item 1208
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 1207
        return "ERR_NOT_FOUND"
    end
end

function check_dst_folder(space_id, folder_id, user_id, roles)
    -- item 1095
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 1096
    if message then
        -- item 1107
        return message
    else
        -- item 1097
        local fdata = find_folder(
        	space_id,
        	folder_id
        )
        -- item 1098
        if fdata then
            -- item 1102
            if is_folder(fdata) then
                -- item 1106
                return nil
            else
                -- item 1105
                return "ERR_NOT_FOLDER"
            end
        else
            -- item 1101
            return "ERR_NOT_FOUND"
        end
    end
end

function check_read_access(space_id, user_id, roles)
    -- item 2951
    local sdata = db.space_get(space_id)
    -- item 360
    if sdata then
        -- item 3034
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	roles
        )
        -- item 36
        if ((access == "admin") or (access == "write")) or (access == "read") then
            -- item 39
            return nil, access, sdata.public
        else
            -- item 362
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 361
        return "ERR_NOT_FOUND"
    end
end

function check_write_access(space_id, user_id, roles)
    -- item 3514
    local sdata = db.space_get(space_id)
    -- item 3510
    if sdata then
        -- item 3515
        local access = get_access(
        	sdata,
        	space_id,
        	user_id,
        	roles
        )
        -- item 3502
        if (access == "admin") or (access == "write") then
            -- item 3505
            return nil
        else
            -- item 3512
            return "ERR_ACCESS_DENIED"
        end
    else
        -- item 3511
        return "ERR_NOT_FOUND"
    end
end

function clear_trash(space_id, user_id, roles)
    -- item 911
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 912
    if message then
        -- item 3111
        return message
    else
        -- item 914
        db.begin()
        -- item 3109
        local folders = get_trash_folders(
        	space_id
        )
        for _, folder_id in ipairs(folders) do
            -- item 935
            delete_forever(
            	space_id,
            	folder_id
            )
            -- item 3110
            remove_from_trash(
            	space_id,
            	folder_id
            )
        end
        -- item 938
        db.commit()
        -- item 939
        return nil
    end
end

function compare_fdata(left, right)
    -- item 1029
    local result = utf8.ncasecmp(
    	left.fdata.name,
    	right.fdata.name
    )
    -- item 1033
    return result < 0
end

function copyNotNil(src, name, dst)
    -- item 1878
    local value = src[name]
    -- item 1875
    if value == nil then
        
    else
        -- item 1879
        dst[name] = value
    end
end

function copy_folder(space_id, folder_id, dst_space_id, dst_folder_id, user_id, plan)
    -- item 2298
    fiber.yield()
    -- item 2300
    db.begin()
    -- item 2032
    local new_id
    local ok = true
    local message = nil
    -- item 1122
    local fdata = db.folder_get(
    	space_id,
    	folder_id
    )
    -- item 1149
    ok, new_id = create_folder_kernel(
    	dst_space_id,
    	fdata,
    	user_id,
    	fdata.version or 0,
    	dst_folder_id
    )
    -- item 2034
    if ok then
        -- item 1769
        local my_items = db.item_get_by_folder(
        	space_id,
        	folder_id
        )
        for _, item in ipairs(my_items) do
            -- item 1290
            local item_id = item[3]
            local idata = item[4]
            -- item 1287
            db.item_insert(
            	dst_space_id,
            	new_id,
            	item_id,
            	idata
            )
        end
        -- item 3202
        local props = db.folder_props_get_by_folder(
        	space_id,
        	folder_id
        )
        for _, prop in ipairs(props) do
            -- item 3205
            local prop_name = prop[3]
            local prop_value = prop[4]
            -- item 3206
            db.folder_props_insert(
            	dst_space_id,
            	new_id,
            	prop_name,
            	prop_value
            )
        end
        -- item 2299
        db.commit()
        -- item 2304
        local children = plan[folder_id]
        -- item 2303
        if children then
            for child_id, _ in pairs(children) do
                -- item 1152
                ok, message = copy_folder(
                	space_id,
                	child_id,
                	dst_space_id,
                	new_id,
                	user_id,
                	plan
                )
                -- item 2038
                if ok then
                    
                else
                    break
                end
            end
        end
    else
        -- item 2301
        db.rollback()
        -- item 2037
        message = new_id
    end
    -- item 2033
    return ok, message
end

function copy_many(items, dst_space_id, dst_folder_id, user_id, roles)
    -- item 2028
    local ok, message
    -- item 1066
    message = check_dst_folder(
    	dst_space_id,
    	dst_folder_id,
    	user_id,
    	roles
    )
    -- item 1067
    if message then
        -- item 1055
        return message
    else
        for _, item in ipairs(items) do
            -- item 1083
            local sdata = find_folder(
            	item.space_id,
            	item.id
            )
            -- item 1084
            if sdata then
                
            else
                -- item 1085
                message = "ERR_NOT_FOUND"
                -- item 1055
                return message
            end
            -- item 1078
            message = check_read_access(
            	item.space_id,
            	user_id,
            	roles
            )
            -- item 1081
            if message then
                -- item 1055
                return message
            end
        end
        for _, item in ipairs(items) do
            -- item 2302
            local plan = {}
            build_copy_plan(
            	item.space_id,
            	item.id,
            	plan
            )
            -- item 1155
            ok, message = copy_folder(
            	item.space_id,
            	item.id,
            	dst_space_id,
            	dst_folder_id,
            	user_id,
            	plan
            )
            -- item 2029
            if ok then
                
            else
                -- item 1055
                return message
            end
        end
        -- item 1054
        return nil
    end
end

function create_folder(space_id, fields, user_id, roles)
    -- item 2100
    local count = 0
    -- item 328
    db.begin()
    -- item 319
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 320
    if message then
        -- item 331
        db.rollback()
        -- item 330
        return false, message, count
    else
        -- item 3142
        local parent_id = extract_parent_id(
        	fields
        )
        -- item 339
        local ok, result, dcount = create_folder_kernel(
        	space_id,
        	fields,
        	user_id,
        	current_version,
        	parent_id
        )
        -- item 504
        if ok then
            -- item 335
            db.commit()
            -- item 336
            return true, result
        else
            -- item 1148
            message = result
            count = dcount
            -- item 331
            db.rollback()
            -- item 330
            return false, message, count
        end
    end
end

function create_folder_kernel(space_id, fields, user_id, version, parent_id)
    -- item 1145
    local sdata = db.space_get(space_id)
    -- item 2023
    local diagrams = get_diagram_count(space_id)
    local limit = get_max_diagrams(sdata)
    -- item 2024
    if (diagrams >= limit) and (not (is_folder(fields))) then
        -- item 2027
        return false, "ERR_DIAGRAM_LIMIT", diagrams + 1
    else
        -- item 1140
        local id = sdata.next_id
        sdata.next_id = id + 1
        local folder_id = tostring(id)
        -- item 2958
        db.space_update(
        	space_id,
        	sdata
        )
        -- item 1141
        local message = db_create_folder(
        	space_id,
        	folder_id,
        	fields,
        	user_id,
        	version,
        	parent_id
        )
        -- item 1143
        if message then
            -- item 1147
            return false, message
        else
            -- item 1139
            return true, folder_id
        end
    end
end

function create_gen_folder(gentoken)
    -- item 3327
    local path = global_cfg.gen_dir ..
      "/" .. gentoken
    -- item 3326
    return fio.mkdir(path)
end

function create_space(space_id, owner, root_id)
    -- item 8
    local now = clock.time()
    -- item 7
    local sdata = {
    	public = false,
    	when_created = now,
    	when_updated = now,
    	next_id = 2,
    	root_id = root_id
    }
    -- item 6
    db.space_insert(space_id, sdata)
    -- item 3049
    db.rights_insert(
    	space_id,
    	owner,
    	"admin",
    	{}
    )
    -- item 1156
    local fields = {
    	type = "folder",
    	name = "<root>"
    }
    -- item 17
    db_create_folder(
    	space_id,
    	root_folder_id,
    	fields,
    	"system",
    	current_version,
    	nil
    )
    -- item 1906
    log_user_event(
    	owner,
    	"create_space",
    	{space = space_id}
    )
end

function db_create_folder(space_id, folder_id, fields, user_id, version, parent_id)
    -- item 16
    local now = clock.time()
    -- item 15
    local fdata = {}
    for key, value in pairs(fields) do
        -- item 1896
        fdata[key] = value
    end
    -- item 1893
    fdata.when_created = now
    fdata.when_updated = now
    fdata.created_by = user_id
    fdata.updated_by = user_id
    fdata.version = version
    fdata.tag = ""
    -- item 14
    db.folder_insert(space_id, folder_id, fdata)
    -- item 407
    if parent_id then
        -- item 394
        return add_child(
        	space_id,
        	parent_id,
        	folder_id,
        	user_id
        )
    else
        -- item 502
        return nil
    end
end

function def_query(data, user_id, roles)
    -- item 3434
    local match
    local found = {}
    -- item 2255
    local space_error, access, is_public = check_read_access(
    	data.space_id,
    	user_id,
    	roles
    )
    -- item 2256
    if space_error then
        -- item 2257
        return false, space_error
    else
        -- item 3430
        if data.tokens then
            -- item 3454
            local tokens = utils.map(
            	data.tokens,
            	utils.normalize_string
            )
            -- item 3440
            match = function(sid, fid, folder)
            	name_matches(
            		sid, fid, folder, 
            		tokens, found
            	)
            end
        else
            -- item 3455
            local lines = utils.map(
            	data.lines,
            	utils.normalize_string
            )
            -- item 2864
            match = function(sid, fid, folder)
            	folder_matches_reversed(
            		sid, fid, folder, 
            		lines, found
            	)
            end
        end
        -- item 2865
        for_space_folders(data.space_id, match)
        -- item 2254
        return true, {
        	items = found
        }
    end
end

function delete_folder(space_id, folder_id)
    -- item 2208
    delete_items(space_id, folder_id)
    -- item 2207
    db.folder_delete(
    	space_id,
    	folder_id
    )
end

function delete_forever(space_id, folder_id)
    -- item 3128
    db.folder_tree_delete(
    	space_id,
    	folder_id
    )
    -- item 3127
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(children) do
        -- item 958
        delete_forever(space_id, child_id)
    end
    -- item 3207
    db.folder_props_delete(
    	space_id,
    	folder_id
    )
    -- item 1857
    delete_folder(space_id, folder_id)
end

function delete_items(space_id, folder_id)
    -- item 2948
    local my_items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, item in ipairs(my_items) do
        -- item 1856
        local item_id = item[3]
        -- item 1852
        db.item_delete(
        	space_id,
        	folder_id,
        	item_id
        )
    end
end

function delete_many(items, user_id, roles)
    -- item 703
    local message
    local deleted = {}
    -- item 573
    db.begin()
    for _, item in ipairs(items) do
        -- item 702
        message = delete_one(
        	item.space_id,
        	item.id,
        	user_id,
        	roles,
        	deleted,
        	true
        )
        -- item 579
        if message then
            -- item 574
            db.rollback()
            -- item 583
            return message
        end
    end
    -- item 575
    db.commit()
    -- item 582
    return nil
end

function delete_one(space_id, folder_id, user_id, roles, deleted, tell_parent)
    -- item 672
    local message = nil
    -- item 676
    local key = space_id .. "/" .. folder_id
    -- item 674
    if deleted[key] then
        
    else
        -- item 677
        deleted[key] = {
        	space_id = space_id,
        	folder_id = folder_id
        }
        -- item 668
        local ok, result = can_edit_folder(
        	space_id,
        	folder_id,
        	user_id,
        	roles
        )
        -- item 669
        if ok then
            -- item 671
            local fdata = result
            -- item 682
            if tell_parent then
                -- item 3129
                db.folder_tree_delete(
                	space_id,
                	folder_id
                )
                -- item 967
                add_to_trash(
                	space_id,
                	{ folder_id }
                )
            end
            -- item 687
            local tag = make_folder_tag()
            -- item 688
            fdata.tag = tag
            remember_update(fdata, user_id)
            fdata.deleted = true
            -- item 2929
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 1496
            remove_from_recent(
            	space_id,
            	folder_id
            )
            -- item 3131
            local children = get_child_folders(
            	space_id,
            	folder_id
            )
            for _, child_id in ipairs(children) do
                -- item 697
                message = delete_one(
                	space_id,
                	child_id,
                	user_id,
                	roles,
                	deleted,
                	false
                )
                -- item 698
                if message then
                    break
                end
            end
        else
            -- item 673
            message = result
        end
    end
    -- item 701
    return message
end

function delete_recent(user_id)
    -- item 2964
    local found = db.recent_get_by_user(user_id)
    for _, item in ipairs(found) do
        -- item 2180
        local space_id = item[1]
        local folder_id = item[2]
        -- item 2181
        db.recent_delete(space_id, folder_id, user_id)
    end
    -- item 2182
    log_user_event(user_id, "delete_recent", {})
end

function delete_space(space_id, user_id, roles)
    -- item 3580
    local space = {}
    -- item 1930
    local message = check_admin_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 1931
    if message then
        
    else
        -- item 2905
        space = db.space_get(space_id)
        -- item 3050
        db.rights_delete_by_space(space_id)
        -- item 1993
        local folders = db.folder_get_by_space(
        	space_id
        )
        for _, folder in ipairs(folders) do
            -- item 1988
            local folder_id = folder[2]
            -- item 1987
            remove_from_recent(
            	space_id,
            	folder_id
            )
            -- item 2211
            delete_folder(
            	space_id,
            	folder_id
            )
        end
        -- item 1990
        db.space_delete(space_id)
        -- item 2292
        log_user_event(
        	user_id,
        	"vud_delete_space",
        	{space_id=space_id}
        )
    end
    -- item 1922
    return message, space.root_id
end

function delete_theme(user_id)
    -- item 2189
    if user_id then
        -- item 2188
        db.user_props_delete(user_id)
    end
end

function edit(space_id, folder_id, data, user_id, roles)
    -- item 282
    db.begin()
    -- item 794
    local message = nil
    -- item 789
    local ok, result = can_edit_folder(
    	space_id,
    	folder_id,
    	user_id,
    	roles
    )
    -- item 790
    if ok then
        -- item 792
        local fdata = result
        -- item 257
        if fdata.tag == data.oldTag then
            -- item 1882
            copyNotNil(data, "name", fdata)
            copyNotNil(data, "keywords", fdata)
            copyNotNil(data, "params", fdata)
            copyNotNil(data, "tag", fdata)
            copyNotNil(data, "background", fdata)
            copyNotNil(data, "diaLine", fdata)
            copyNotNil(data, "diaLineThickness", fdata)
            copyNotNil(data, "font", fdata)
            -- item 1279
            remember_update(fdata, user_id)
            -- item 2930
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 1844
            if data.editType == "replace" then
                -- item 1858
                delete_items(space_id, folder_id)
                for _, ritem in ipairs(data.items) do
                    -- item 1861
                    db.item_insert(
                    	space_id,
                    	folder_id,
                    	ritem.id,
                    	ritem
                    )
                end
            else
                -- item 1888
                local deleted = {}
                -- item 284
                if data.removed then
                    for _, ritem in ipairs(data.removed) do
                        -- item 2947
                        db.item_delete(
                        	space_id,
                        	folder_id,
                        	ritem
                        )
                        -- item 1889
                        deleted[ritem] = true
                    end
                end
                -- item 296
                if data.added then
                    for _, aitem in ipairs(data.added) do
                        -- item 301
                        db.item_insert(
                        	space_id,
                        	folder_id,
                        	aitem.id,
                        	aitem
                        )
                    end
                end
                -- item 290
                if data.updated then
                    for _, uitem in ipairs(data.updated) do
                        -- item 295
                        update_item(
                        	space_id,
                        	folder_id,
                        	uitem.id,
                        	uitem,
                        	deleted
                        )
                    end
                end
            end
            -- item 283
            db.commit()
            -- item 255
            return nil
        else
            -- item 272
            message = "ERR_MODIFIED"
            -- item 481
            db.rollback()
            -- item 482
            return message
        end
    else
        -- item 793
        message = result
        -- item 481
        db.rollback()
        -- item 482
        return message
    end
end

function export_folder(space_id, folder_id, folder_list, item_list)
    -- item 2363
    local fdata = find_folder(space_id, folder_id)
    -- item 2364
    if fdata then
        -- item 2367
        local folder_item = {
        	folder_id = folder_id,
        	fdata = fdata
        }
        -- item 2368
        table.insert(folder_list, folder_item)
        -- item 2949
        local my_items = db.item_get_by_folder(
        	space_id,
        	folder_id
        )
        for _, item in ipairs(my_items) do
            -- item 2373
            local item_id = item[3]
            local fields = item[4]
            -- item 2374
            local item_record = {
            	folder_id = folder_id,
            	item_id = item_id,
            	fields = fields
            }
            -- item 2375
            table.insert(item_list, item_record)
        end
    end
end

function export_space(space_id, filename)
    -- item 2346
    local folder_list = {}
    local item_list = {}
    -- item 2941
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, folder in ipairs(folders) do
        -- item 2344
        local folder_id = folder[2]
        -- item 2343
        export_folder(
        	space_id,
        	folder_id,
        	folder_list,
        	item_list
        )
    end
    -- item 2347
    local result = {
    	folders = folder_list,
    	items = item_list
    }
    -- item 2376
    utils.write_json(filename, result)
end

function extend_life(self)
    -- item 2650
    local timeout = 20
    -- item 2652
    self.expiry = os.time() + timeout
end

function extract_parent_id(fields)
    -- item 3151
    local parent_id = fields.parent
    -- item 3152
    fields.parent = nil
    -- item 3148
    if parent_id == "" then
        -- item 3153
        return nil
    else
        -- item 3154
        return parent_id
    end
end

function find_cycle(space_id, moving_id, target_id)
    while true do
        -- item 512
        if target_id then
            
        else
            -- item 520
            return false
        end
        -- item 517
        if target_id == moving_id then
            -- item 521
            return true
        end
        -- item 3172
        target_id = db.folder_tree_get(
        	space_id,
        	target_id
        )
    end
end

function find_folder(space_id, folder_id)
    -- item 347
    if folder_id then
        -- item 2927
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 372
        if (fdata) and (not (fdata.deleted)) then
            -- item 353
            return fdata
        else
            -- item 350
            return nil
        end
    else
        -- item 350
        return nil
    end
end

function find_folders(space_id, needle, user_id, roles)
    -- item 2759
    ej.info(
    	"find_folders",
    	{user_id=user_id, needle=needle,
    	space_id=space_id}
    )
    -- item 2424
    local space_error, a, p = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 2425
    if space_error then
        -- item 2427
        return false, space_error
    else
        -- item 2459
        needle = utils.normalize_string(needle)
        -- item 2443
        local folders = {}
        -- item 2441
        local match = function(sid, fid, folder)
        	folder_matches(
        		sid, fid, folder, 
        		needle, folders
        	)
        end
        -- item 2492
        for_space_folders(space_id, match)
        -- item 2451
        local result = {
        	folders = folders
        }
        -- item 2450
        return true, result
    end
end

function find_move_cycle(dst_space_id, dst_folder_id, space_id, folder_id)
    -- item 1413
    if (dst_space_id == space_id) and (find_cycle(dst_space_id, folder_id, dst_folder_id)) then
        -- item 1417
        return true
    else
        -- item 1416
        return false
    end
end

function folder_matches(space_id, folder_id, folder, needle, result)
    -- item 2489
    if norm_contains(folder.name, needle) then
        -- item 2487
        local folder_info = make_found_folder(
        	space_id,
        	folder_id,
        	folder
        )
        -- item 2486
        table.insert(result, folder_info)
    end
end

function folder_matches_reversed(space_id, folder_id, folder, lines, result)
    -- item 2860
    local name = utils.normalize_string(
    	folder.name
    )
    for _, line in ipairs(lines) do
        -- item 2857
        if utils.string_contains_words(line, name) then
            -- item 2856
            local folder_info = make_found_folder(
            	space_id,
            	folder_id,
            	folder
            )
            -- item 2855
            table.insert(result, folder_info)
            break
        end
    end
end

function for_space_folders(space_id, action)
    -- item 2942
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, row in ipairs(folders) do
        -- item 2471
        local folder_id = row[2]
        local folder = row[3]
        -- item 2473
        if ((folder) and (not (folder_id == "1"))) and (not (is_deleted(folder))) then
            -- item 2472
            action(
            	space_id,
            	folder_id,
            	folder
            )
        end
    end
end

function get_access(sdata, space_id, user_id, roles)
    -- item 96
    if roles.admin then
        -- item 110
        return "admin"
    else
        -- item 195
        if user_id == "" then
            -- item 194
            if (sdata.public) or (roles.system) then
                -- item 113
                return "read"
            else
                -- item 109
                return nil
            end
        else
            -- item 3063
            local accesses = get_accesses(
            	space_id,
            	user_id
            )
            -- item 100
            if accesses.admin then
                -- item 110
                return "admin"
            else
                -- item 103
                if accesses.write then
                    -- item 111
                    return "write"
                else
                    -- item 106
                    if accesses.read then
                        -- item 113
                        return "read"
                    else
                        -- item 194
                        if (sdata.public) or (roles.system) then
                            -- item 113
                            return "read"
                        else
                            -- item 109
                            return nil
                        end
                    end
                end
            end
        end
    end
end

function get_access_for_space(space_id)
    -- item 3076
    local rights = db.rights_get_by_space(
    	space_id
    )
    -- item 3073
    local readers = {}
    local writers = {}
    local admins = {}
    for _, right in ipairs(rights) do
        -- item 3070
        local user_id = right[2]
        local access = right[3]
        -- item 30780001
        if access == "admin" then
            -- item 3086
            admins[user_id] = true
        else
            -- item 30780002
            if access == "write" then
                -- item 3087
                writers[user_id] = true
            else
                -- item 30780003
                if access == "read" then
                    
                else
                    -- item 30780004
                    error(access)
                end
                -- item 3088
                readers[user_id] = true
            end
        end
    end
    -- item 3077
    return {
    	readers = utils.set_to_list(readers),
    	writers = utils.set_to_list(writers),
    	admins = utils.set_to_list(admins)
    }
end

function get_accesses(space_id, user_id)
    -- item 3056
    local rights = db.rights_get_by_space_user(
    	space_id,
    	user_id
    )
    -- item 3053
    local accesses = {}
    for _, right in ipairs(rights) do
        -- item 3047
        local access = right[3]
        -- item 3054
        accesses[access] = true
    end
    -- item 3055
    return accesses
end

function get_actual_users(rights)
    -- item 2078
    local all = {}
    for _, right in ipairs(rights) do
        -- item 2978
        local access = right[3]
        local user_id = right[2]
        -- item 2979
        if access == "read" then
            
        else
            -- item 2982
            all[user_id] = true
        end
    end
    -- item 2077
    local all_list = utils.set_to_list(all)
    -- item 2082
    return #all_list
end

function get_admins(rights)
    -- item 2992
    local admins = {}
    for _, right in ipairs(rights) do
        -- item 2996
        local access = right[3]
        local user_id = right[2]
        -- item 2997
        if access == "admin" then
            -- item 3000
            table.insert(
            	admins,
            	user_id
            )
        end
    end
    -- item 2993
    return admins
end

function get_basic_limits()
    -- item 2145
    local product = utils.get_product("basic")
    -- item 2146
    return {
    	max_spaces = product.max_spaces,
    	max_diagrams = product.max_diagrams,
    	max_users = product.max_users
    }
end

function get_child_folders(space_id, parent_id)
    -- item 3121
    local get_folder_id = function(row)
    	return row[2]
    end
    -- item 3122
    local rows = db.folder_tree_get_by_parent(
    	space_id,
    	parent_id
    )
    -- item 3123
    local result = utils.map(
    	rows,
    	get_folder_id
    )
    -- item 3179
    return result
end

function get_children(space_id, folder_id)
    -- item 161
    local children = {}
    local language = nil
    local path, language
    local module, module_name
    -- item 3133
    local kids = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(kids) do
        -- item 2919
        local cdata = db.folder_get(
        	space_id,
        	child_id
        )
        -- item 356
        if (cdata) and (not (is_deleted(cdata))) then
            -- item 170
            local item = {
            	space_id = space_id,
            	id = child_id,
            	type = cdata.type,
            	name = cdata.name,
            	params = cdata.params,
            	keywords = cdata.keywords
            }
            -- item 3570
            if cdata.type == "module" then
                -- item 3573
                path, language, module, module_name =
                	get_path(space_id, child_id)
                -- item 3579
                item.language = language
                item.module = module
                item.module_name = module_name
            end
            -- item 171
            table.insert(children, item)
        end
    end
    -- item 162
    return children
end

function get_create_gentoken(space_id, user_id, roles)
    -- item 3307
    local gentoken = nil
    local result = nil
    local ok = nil
    -- item 3292
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 3293
    if space_error then
        -- item 3295
        ok = false
        result = space_error
    else
        -- item 3300
        local sdata = db.space_get(space_id)
        -- item 3301
        if sdata.gentoken then
            -- item 3304
            gentoken = sdata.gentoken
            -- item 3332
            result = {
            	gentoken = gentoken
            }
            ok = true
        else
            -- item 3309
            gentoken = utils.random_password(32)
            -- item 3319
            if create_gen_folder(gentoken) then
                -- item 3311
                sdata.gentoken = gentoken
                -- item 3310
                db.space_update(
                	space_id,
                	sdata
                )
                -- item 3332
                result = {
                	gentoken = gentoken
                }
                ok = true
            else
                -- item 3331
                ok = false
                result = "ERROR_COULD_NOT_CREATE_FOLDER"
            end
        end
    end
    -- item 3383
    return ok, result
end

function get_diagram_count(space_id)
    -- item 2014
    local count = 0
    -- item 2943
    local folders = db.folder_get_by_space(
    	space_id
    )
    for _, folder in ipairs(folders) do
        -- item 2018
        local fdata = folder[3]
        -- item 2019
        if (is_folder(fdata)) or (fdata.deleted) then
            
        else
            -- item 2022
            count = count + 1
        end
    end
    -- item 2015
    return count
end

function get_drakons(space_id, folder_id, drakons)
    local _sw34870000_ = 0
    -- item 3483
    local children = get_children(
    	space_id,
    	folder_id
    )
    for _, child in ipairs(children) do
        -- item 34870000
        _sw34870000_ = child.type
        -- item 34870001
        if _sw34870000_ == "drakon" then
            -- item 3496
            table.insert(
            	drakons,
            	child
            )
        else
            -- item 34870002
            if _sw34870000_ == "folder" then
                -- item 3495
                get_drakons(
                	child.space_id,
                	child.id,
                	drakons
                )
            end
        end
    end
end

function get_first_admin(space_id)
    -- item 2953
    local sdata = db.space_get(space_id)
    -- item 2893
    return sdata.admins[1]
end

function get_folder(space_id, folder_id, visit, user_id, roles)
    -- item 85
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 86
    if space_error then
        -- item 88
        return false, space_error
    else
        -- item 23
        local fdata = find_folder(space_id, folder_id)
        -- item 28
        if fdata then
            -- item 1455
            if ((user_id == "") or (not (visit))) or (is_folder(fdata)) then
                
            else
                -- item 1459
                add_to_recent(
                	space_id,
                	folder_id,
                	user_id
                )
            end
            -- item 137
            local path, language, module, module_name =
            	get_path(space_id, folder_id)
            local items = get_items(space_id, folder_id)
            local children = get_children(space_id, folder_id)
            local parent = db.folder_tree_get(
            	space_id,
            	folder_id
            )
            -- item 3575
            if module then
                for _, child in ipairs(children) do
                    -- item 3569
                    child.module = module
                    child.module_name = module_name
                end
            end
            -- item 90
            local result = {
            	id = folder_id,
            	space_id = space_id,
            	name = fdata.name,
            	type = fdata.type,
            	tag = fdata.tag,
            	params = fdata.params,
            	keywords = fdata.keywords,
            	parent = parent,
            	description = fdata.description,
            	access = access,
            	children = children,
            	items = items,
            	path = path,
            	is_public = is_public,
            	version = fdata.version or 0,
            	language = language,
            	module = module,
            	module_name = module_name
            }
            -- item 138
            return true, result
        else
            -- item 89
            return false, "ERR_NOT_FOUND"
        end
    end
end

function get_folder_props(space_id, folder_id, user_id, roles)
    -- item 3217
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 3218
    if space_error then
        -- item 3220
        return false, space_error
    else
        -- item 3225
        local props = db.folder_props_get_by_folder(
        	space_id,
        	folder_id
        )
        -- item 3226
        local result = {}
        for _, prop in ipairs(props) do
            -- item 3229
            result[prop[3]] = prop[4]
        end
        -- item 3536
        add_default_html(
        	space_id,
        	folder_id,
        	user_id,
        	roles,
        	result
        )
        -- item 3224
        return true, result
    end
end

function get_item_text(item)
    -- item 2822
    return item.text or ""
end

function get_item_text2(item)
    -- item 3198
    return item.text2 or ""
end

function get_items(space_id, folder_id)
    -- item 180
    local result = {}
    -- item 2950
    local my_items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, item in ipairs(my_items) do
        -- item 187
        local item_id = item[3]
        local idata = item[4]
        idata.id = item_id
        -- item 190
        table.insert(result, idata)
    end
    -- item 181
    return result
end

function get_language(space_id, folder_id)
    -- item 3427
    return db.folder_props_get(
    	space_id,
    	folder_id,
    	"language"
    )
end

function get_max_access(space_id, user_id)
    -- item 3062
    local accesses = get_accesses(
    	space_id,
    	user_id
    )
end

function get_max_diagrams(sdata)
    -- item 2004
    if sdata.max_diagrams then
        -- item 2003
        return sdata.max_diagrams
    else
        -- item 2147
        local limits = get_basic_limits()
        -- item 2007
        return limits.max_diagrams
    end
end

function get_max_users(sdata)
    -- item 2059
    if sdata.max_users then
        -- item 2058
        return sdata.max_users
    else
        -- item 2149
        local limits = get_basic_limits()
        -- item 2148
        return limits.max_users
    end
end

function get_module(space_id, folder_id, user_id, roles)
    -- item 3470
    local space_error, access, is_public =
     check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 3471
    if space_error then
        -- item 3473
        return false, space_error
    else
        -- item 3466
        local fdata = find_folder(
        	space_id,
        	folder_id
        )
        -- item 3468
        if fdata then
            -- item 3497
            local drakons = {}
            -- item 3476
            get_drakons(
            	space_id,
            	folder_id,
            	drakons
            )
            -- item 3475
            local result = {
            	id = folder_id,
            	space_id = space_id,
            	name = fdata.name,
            	type = fdata.type,
            	tag = fdata.tag,
            	description = fdata.description,
            	diagrams = drakons
            }
            -- item 3477
            return true, result
        else
            -- item 3474
            return false, "ERR_NOT_FOUND"
        end
    end
end

function get_parent_id_for_restore(space_id, folder_id)
    -- item 3166
    local parent_id = db.folder_tree_get(
    	space_id,
    	folder_id
    )
    -- item 3161
    if parent_id then
        -- item 3160
        local parent = db.folder_get(
        	space_id,
        	parent_id
        )
        -- item 3167
        if parent.deleted then
            -- item 3164
            parent_id = root_folder_id
        end
    else
        -- item 3164
        parent_id = root_folder_id
    end
    -- item 3168
    return parent_id
end

function get_path(space_id, folder_id)
    -- item 144
    local path = {}
    local language = nil
    local module = nil
    local module_name = nil
    local fdata
    while true do
        -- item 145
        fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 3252
        if fdata.type == "module" then
            -- item 3251
            language = db.folder_props_get(
            	space_id,
            	folder_id,
            	"language"
            )
            -- item 3256
            module = folder_id
            module_name = fdata.name
        end
        -- item 151
        table.insert(
        	path,
        	{
        		space_id = space_id,
        		id = folder_id,
        		name = fdata.name
        	}
        )
        -- item 3170
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 146
        if folder_id then
            
        else
            break
        end
    end
    -- item 149
    return utils.reverse(path), language, module, module_name
end

function get_prog_modules(space_id, user_id, roles)
    -- item 3399
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 3400
    if message then
        -- item 3409
        return false, message
    else
        -- item 3419
        local result = {
        	modules = {}
        }
        -- item 3412
        local folders = db.folder_get_by_space(
        	space_id
        )
        for _, folder in ipairs(folders) do
            -- item 3413
            local folder_id = folder[2]
            local fdata = folder[3]
            -- item 3414
            if (fdata.deleted) or (not (fdata.type == "module")) then
                
            else
                -- item 3428
                local language = get_language(
                	space_id,
                	folder_id
                )
                -- item 3429
                if (language) and (not (language == "LANG_HUMAN")) then
                    -- item 3420
                    local module = {
                    	space_id = space_id,
                    	folder_id = folder_id,
                    	name = fdata.name,
                    	language = language
                    }
                    -- item 3421
                    table.insert(
                    	result.modules,
                    	module
                    )
                end
            end
        end
        -- item 3408
        return true, result
    end
end

function get_recent(user_id)
    -- item 1511
    local result = {}
    -- item 1512
    if user_id == "" then
        
    else
        -- item 2965
        local found = db.recent_get_by_user(user_id)
        for _, item in ipairs(found) do
            -- item 1521
            local record = {
                space_id = item[1],
                folder_id = item[2],
                whenOpened = item[4].when
            }
            -- item 2295
            local folder = db.folder_get(
            	record.space_id,
            	record.folder_id
            )
            -- item 1522
            record.name = folder.name
            record.type = folder.type
            record.path, record.language, 
            record.module, record.module_name = get_path(
            	record.space_id,
            	record.folder_id
            )
            -- item 1524
            table.insert(result, record)
        end
        -- item 1520
        local compare_name = function(left, right)
        	local lname = left.name
        	local rname = right.name
        	local comp = utf8.ncasecmp(lname, rname)
        	return comp < 0
        end
        -- item 1766
        local compare_when = function(left, right)
        	return left.whenOpened > right.whenOpened
        end
        -- item 1523
        table.sort(
        	result,
        	compare_when
        )
    end
    -- item 1515
    return true, {
    	recent = result
    }
end

function get_search(session_id)
    -- item 2703
    return globs.searches[session_id]
end

function get_short_path(space_id, folder_id)
    -- item 2840
    local path = {}
    while true do
        -- item 2921
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 2845
        table.insert(path, fdata.name)
        -- item 3171
        folder_id = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 2842
        if folder_id == "1" then
            break
        end
    end
    -- item 2848
    table.insert(path, space_id)
    -- item 2843
    return utils.reverse(path)
end

function get_space_access(space_id, user_id, roles)
    -- item 2321
    local space_error, access, is_public = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 2322
    if space_error then
        -- item 2325
        return nil
    else
        -- item 2326
        return access
    end
end

function get_space_diagrams(space_id)
    -- item 2592
    local diagrams = {}
    -- item 2591
    local match = function(sid, fid, folder)
    	match_diagrams(
    		sid, fid, folder, 
    		diagrams
    	)
    end
    -- item 2593
    for_space_folders(space_id, match)
    -- item 2594
    return diagrams
end

function get_tag(space_id, folder_id)
    -- item 201
    local fdata = find_folder(space_id, folder_id)
    -- item 202
    if fdata then
        -- item 207
        return true, fdata.tag
    else
        -- item 204
        return false, "ERR_NOT_FOUND"
    end
end

function get_theme(user_id)
    -- item 3257
    local rows = db.user_props_get_by_user(user_id)
    -- item 3258
    local result = {}
    for _, row in ipairs(rows) do
        -- item 3261
        result[row[2]] = row[3]
    end
    -- item 218
    return true, result
end

function get_trash(space_id, user_id, roles)
    -- item 758
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 759
    if space_error then
        -- item 761
        return false, space_error
    else
        -- item 3104
        local folders = get_trash_folders(
        	space_id
        )
        -- item 770
        local result = {
        	access = access,
        	items = {}
        }
        for _, folder_id in ipairs(folders) do
            -- item 795
            local fdata = db.folder_get(space_id, folder_id)
            -- item 777
            local item = {
            	space_id = space_id,
            	id = folder_id,
            	type = fdata.type,
            	name = fdata.name
            }
            -- item 778
            table.insert(
            	result.items,
            	item
            )
        end
        -- item 771
        return true, result
    end
end

function get_trash_folders(space_id)
    -- item 3095
    local rows = db.trash_get_by_space(space_id)
    -- item 3105
    local get_folder_id = function(row)
    	return row[2]
    end
    -- item 3103
    return utils.map(
    	rows,
    	get_folder_id
    )
end

function get_tree(space_id, user_id, roles)
    -- item 994
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 995
    if space_error then
        -- item 997
        return false, space_error
    else
        -- item 1002
        local lines = {}
        -- item 1049
        local root = db.folder_get(
        	space_id,
        	"1"
        )
        -- item 1003
        add_tree_node(
        	space_id,
        	"1",
        	root,
        	0,
        	lines
        )
        -- item 1004
        local result = {
        	lines = lines
        }
        -- item 1001
        return true, result
    end
end

function get_user_limits(user_id)
    -- item 2158
    local user = vud.get_user(user_id)
    -- item 2171
    if user then
        -- item 2159
        local license = lic.get_license(user.license)
        -- item 2164
        if license then
            -- item 2163
            return license.limits
        else
            -- item 2162
            return get_basic_limits()
        end
    else
        -- item 2162
        return get_basic_limits()
    end
end

function import_space(space_id, filename, owner)
    -- item 2394
    create_space(space_id, owner)
    -- item 2937
    db.folder_delete(
    	space_id,
    	"1"
    )
    -- item 2402
    local obj = utils.read_json(filename)
    -- item 2405
    local min_id = 1
    for _, folder in ipairs(obj.folders) do
        -- item 2406
        local id = tonumber(folder.folder_id)
        -- item 2407
        min_id = math.max(min_id, id)
    end
    -- item 2408
    local next_id = min_id + 1
    for _, folder in ipairs(obj.folders) do
        -- item 2414
        db.folder_insert(
        	space_id,
        	folder.folder_id,
        	folder.fdata
        )
    end
    for _, item in ipairs(obj.items) do
        -- item 2397
        db.item_insert(
        	space_id,
        	item.folder_id,
        	item.item_id,
        	item.fields
        )
    end
    -- item 2954
    local sdata = db.space_get(space_id)
    -- item 2417
    sdata.next_id = next_id
    -- item 2959
    db.space_update(
    	space_id,
    	sdata
    )
end

function insert_items_from_map(space_id, folder_id, items_map)
    -- item 2229
    if items_map then
        for item_id, item in pairs(items_map) do
            -- item 2235
            item.id = nil
            -- item 2234
            db.item_insert(
            	space_id,
            	folder_id,
            	item_id,
            	item
            )
        end
    end
end

function is_deleted(folder)
    -- item 2439
    local deleted = not not folder.deleted
    -- item 2440
    return deleted
end

function is_diagram_like(fields, names)
    -- item 2272
    if is_folder(fields) then
        -- item 2276
        return false
    else
        -- item 2277
        local dia_name = utils.parse_compound_name(
        	fields.name
        )
        for _, name in ipairs(names) do
            -- item 2278
            if name == dia_name then
                -- item 2280
                return true
            end
        end
        -- item 2281
        return false
    end
end

function is_folder(obj)
    local _sw31850000_ = 0
    -- item 31850000
    _sw31850000_ = obj.type
    -- item 31850001
    if ((_sw31850000_ == "folder") or (_sw31850000_ == "module")) or (_sw31850000_ == "class") then
        -- item 3196
        return true
    else
        -- item 3197
        return false
    end
end

function log_user_event(user_id, type, data)
    -- item 1904
    data.user_id = user_id
    -- item 1905
    ej.info(type, data)
end

function make_default_html(name, mformat, gentoken)
    -- item 3561
    local template
    -- item 3562
    if mformat == "MES_ES6" then
        -- item 3565
        template = default_html_es6
    else
        -- item 3566
        template = default_html
    end
    -- item 3559
    local p2 = template:gsub("@name@", name)
    -- item 3560
    return p2:gsub("@gentoken@", gentoken)
end

function make_folder_tag()
    -- item 392
    local t = clock.time()
    return tostring(t * 10000)
end

function make_found_folder(space_id, folder_id, folder)
    -- item 2457
    local result = {
    	space_id = space_id,
    	folder_id = folder_id,
    	name = folder.name,
    	type = folder.type,
    	path = get_short_path(space_id, folder_id)
    }
    -- item 2458
    return result
end

function match_diagrams(space_id, folder_id, folder, result)
    -- item 2544
    if is_folder(folder) then
        
    else
        -- item 2542
        local folder_info = {
        	space_id = space_id,
        	folder_id = folder_id,
        	fields = folder
        }
        -- item 2541
        table.insert(result, folder_info)
    end
end

function move_many(items, dst_space_id, dst_folder_id, user_id, roles)
    -- item 1311
    local message = check_dst_folder(
    	dst_space_id,
    	dst_folder_id,
    	user_id,
    	roles
    )
    -- item 1312
    if message then
        -- item 1305
        return false, message
    else
        for _, item in ipairs(items) do
            -- item 1445
            if item.space_id == dst_space_id then
                
            else
                -- item 1446
                message = "ERR_CANT_MOVE_ACROSS"
                -- item 1305
                return false, message
            end
            -- item 1322
            local ok, fdata = can_edit_folder(
            	item.space_id,
            	item.id,
            	user_id,
            	roles
            )
            -- item 1323
            if ok then
                
            else
                -- item 1324
                message = fdata
                -- item 1305
                return false, message
            end
            -- item 1419
            local cycle = find_move_cycle(
            	dst_space_id,
            	dst_folder_id,
            	item.space_id,
            	item.id
            )
            -- item 1406
            if cycle then
                -- item 1407
                message = "ERR_CYCLE"
                -- item 1305
                return false, message
            end
        end
        -- item 1356
        local sorted = sort_for_move(items)
        for _, item in ipairs(sorted) do
            -- item 1427
            message = move_via_reparent(
            	item.space_id,
            	item.id,
            	dst_folder_id,
            	user_id
            )
            -- item 1357
            if message then
                -- item 1305
                return false, message
            end
        end
        -- item 1452
        local result = {
        	items = sorted
        }
        -- item 1304
        return true, result
    end
end

function move_via_reparent(space_id, folder_id, new_parent, user_id)
    -- item 1442
    db.folder_tree_upsert(
    	space_id,
    	folder_id,
    	new_parent
    )
    -- item 1439
    return nil
end

function multi_access(data, user_id, roles)
    for _, block in ipairs(data.blocks) do
        -- item 1755
        local grant = (block.action == "grant")
        -- item 1745
        local message, count = access_core(
        	block,
        	grant,
        	user_id,
        	roles
        )
        -- item 1746
        if message then
            -- item 1751
            return message, count
        end
    end
    -- item 1756
    if data.setPublicAccess then
        -- item 1759
        local sdata = db.space_get(data.spaceId)
        sdata.public = data.publicAccess
        -- item 2960
        db.space_update(
        	data.spaceId,
        	sdata
        )
        -- item 1907
        log_user_event(
        	user_id,
        	"public access",
        	{space=data.spaceId, public=sdata.public}
        )
    end
    -- item 1750
    return nil
end

function name_matches(space_id, folder_id, folder, tokens, result)
    -- item 3451
    local name = utils.normalize_string(
    	folder.name
    )
    for _, token in ipairs(tokens) do
        -- item 3448
        if token == name then
            -- item 3447
            local folder_info = make_found_folder(
            	space_id,
            	folder_id,
            	folder
            )
            -- item 3446
            table.insert(result, folder_info)
            break
        end
    end
end

function norm_contains(haystack, needle)
    -- item 2793
    if haystack then
        -- item 2791
        local norm_haystack = utils.normalize_string(
        	haystack
        )
        -- item 2792
        return utils.string_contains(
        	norm_haystack,
        	needle
        )
    else
        -- item 2796
        return false
    end
end

function read_access(space_id, user_id, roles)
    -- item 1603
    local space_error, access = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 1604
    if space_error then
        -- item 1606
        return false, space_error
    else
        -- item 1607
        local sdata = db.space_get(space_id)
        -- item 3089
        local result = get_access_for_space(
        	space_id
        )
        -- item 1608
        result.public = sdata.public
        -- item 1601
        return true, result
    end
end

function remember_update(fields, user_id)
    -- item 1277
    fields.updated_by = user_id
    fields.when_updated = clock.time()
end

function remove_from_recent(space_id, folder_id)
    -- item 2966
    local found = db.recent_get_by_folder(
    	space_id,
    	folder_id
    )
    for _, record in ipairs(found) do
        -- item 1492
        local user_id = record[3]
        -- item 1491
        db.recent_delete(
        	space_id,
        	folder_id,
        	user_id
        )
    end
end

function remove_from_trash(space_id, folder_id)
    -- item 3107
    db.trash_delete(space_id, folder_id)
end

function remove_gen_folder(gentoken)
    -- item 3340
    local path = global_cfg.gen_dir ..
      "/" .. gentoken
    -- item 3384
    local pattern = path .. "/*"
    -- item 3385
    local files = fio.glob(pattern)
    for _, file in ipairs(files) do
        -- item 3390
        if os.remove(file) then
            
        else
            -- item 3393
            return false
        end
    end
    -- item 3339
    return os.remove(path)
end

function reset_gentoken(space_id, user_id, roles)
    -- item 3364
    local result = nil
    local ok = nil
    -- item 3351
    local space_error = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 3352
    if space_error then
        -- item 3354
        ok = false
        result = space_error
    else
        -- item 3363
        db.begin()
        -- item 3359
        local sdata = db.space_get(space_id)
        -- item 3360
        if sdata.gentoken then
            -- item 3372
            if remove_gen_folder(sdata.gentoken) then
                -- item 3368
                sdata.gentoken = nil
                -- item 3367
                db.space_update(
                	space_id,
                	sdata
                )
                -- item 3370
                db.commit()
                -- item 3382
                ok, result = get_create_gentoken(
                	space_id,
                	user_id,
                	roles
                )
            else
                -- item 3375
                db.rollback()
                -- item 3376
                ok = false
                result = "ERROR_COULD_NOT_REMOVE_FOLDER"
            end
        else
            -- item 3369
            db.commit()
            -- item 3382
            ok, result = get_create_gentoken(
            	space_id,
            	user_id,
            	roles
            )
        end
    end
    -- item 3365
    return ok, result
end

function restore(space_id, folder_id, user_id, roles)
    -- item 823
    db.begin()
    -- item 867
    local message = check_write_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 868
    if message then
        -- item 855
        db.rollback()
        -- item 856
        return message
    else
        -- item 2922
        local fdata = db.folder_get(
        	space_id,
        	folder_id
        )
        -- item 865
        if fdata then
            -- item 812
            if fdata.deleted then
                -- item 872
                local parent_id = get_parent_id_for_restore(
                	space_id,
                	folder_id
                )
                -- item 878
                local tag = make_folder_tag()
                -- item 816
                fdata.tag = tag
                fdata.deleted = false
                -- item 1281
                remember_update(fdata, user_id)
                -- item 3169
                db.folder_tree_upsert(
                	space_id,
                	folder_id,
                	parent_id
                )
                -- item 2933
                db.folder_update(
                	space_id,
                	folder_id,
                	fdata
                )
                -- item 3135
                local children = get_child_folders(
                	space_id,
                	folder_id
                )
                for _, child_id in ipairs(children) do
                    -- item 971
                    restore_recursive(
                    	space_id,
                    	child_id
                    )
                end
                -- item 880
                add_child(
                	space_id,
                	parent_id,
                	folder_id,
                	user_id
                )
                -- item 895
                remove_from_trash(
                	space_id,
                	folder_id
                )
                -- item 824
                db.commit()
                -- item 811
                return nil
            else
                -- item 813
                message = "ERR_NOT_DELETED"
                -- item 855
                db.rollback()
                -- item 856
                return message
            end
        else
            -- item 866
            message = "ERR_NOT_FOUND"
            -- item 855
            db.rollback()
            -- item 856
            return message
        end
    end
end

function restore_recursive(space_id, folder_id)
    -- item 982
    local fdata = db.folder_get(
    	space_id,
    	folder_id
    )
    -- item 983
    fdata.deleted = false
    -- item 2934
    db.folder_update(
    	space_id,
    	folder_id,
    	fdata
    )
    -- item 3137
    local children = get_child_folders(
    	space_id,
    	folder_id
    )
    for _, child_id in ipairs(children) do
        -- item 979
        restore_recursive(
        	space_id,
        	child_id
        )
    end
end

function save_try(data, user_id)
    -- item 1559
    local space_id = user_id
    local count = 0
    -- item 1582
    db.begin()
    -- item 1543
    local message = check_write_access(
    	space_id,
    	user_id,
    	{}
    )
    -- item 1556
    if message then
        -- item 1554
        db.rollback()
        -- item 2239
        log_user_event(
        	user_id,
        	"save_try-failed",
        	{message=message}
        )
        -- item 1555
        return false, message, count
    else
        -- item 1565
        local fields = {
        	type = data.type,
        	name = data.name,
        	background = data.background,
        	diaLine = data.diaLine,
        	diaLineThickness = data.diaLineThickness,
        	font = data.font
        }
        -- item 1560
        local ok, folder_id, dcount = create_folder_kernel(
        	space_id,
        	fields,
        	user_id,
        	current_version,
        	root_folder_id
        )
        -- item 1563
        if ok then
            -- item 2236
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.free
            )
            -- item 2237
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.nodes
            )
            -- item 2238
            insert_items_from_map(
            	space_id,
            	folder_id,
            	data.edges
            )
            -- item 1561
            db.commit()
            -- item 1562
            return true, folder_id, 0
        else
            -- item 1567
            message = folder_id
            count = dcount
            -- item 1554
            db.rollback()
            -- item 2239
            log_user_event(
            	user_id,
            	"save_try-failed",
            	{message=message}
            )
            -- item 1555
            return false, message, count
        end
    end
end

function seach_text_chunk(item_id, text, needle, found)
    -- item 3529
    if norm_contains(text, needle) then
        -- item 3528
        local match = {
        	item_id = item_id,
        	text = text
        }
        -- item 3527
        table.insert(found, match)
        -- item 3532
        return true
    else
        -- item 3533
        return false
    end
end

function search_add(session_id, search)
    -- item 2548
    search_delete(session_id)
    -- item 2535
    globs.searches[session_id] = search
end

function search_delete(session_id)
    -- item 2722
    local search = globs.searches[session_id]
    -- item 2723
    if search then
        -- item 2726
        search.state = nil
        -- item 2727
        globs.searches[session_id] = nil
    end
end

function search_items_get(session_id)
    -- item 2704
    local search = get_search(session_id)
    -- item 2706
    if search then
        -- item 2705
        local result = {}
        -- item 2710
        search:get(result)
        -- item 2711
        return result
    else
        -- item 2757
        return nil
    end
end

function search_items_start(session_id, space_id, needle, user_id, roles)
    -- item 2758
    ej.info(
    	"search_items_start",
    	{user_id=user_id, needle=needle,
    	space_id=space_id}
    )
    -- item 2508
    local space_error, a, p = check_read_access(
    	space_id,
    	user_id,
    	roles
    )
    -- item 2509
    if space_error then
        -- item 2743
        return false, space_error
    else
        -- item 2751
        local norm_needle = utils.normalize_string(
        	needle
        )
        -- item 2754
        local diagrams = get_space_diagrams(
        	space_id
        )
        -- item 2712
        local msg = {
        	space_id = space_id,
        	needle = norm_needle,
        	session_id = session_id,
        	diagrams = diagrams
        }
        -- item 2515
        local search = search_machine()
        -- item 2714
        search:update(msg)
        -- item 2968
        local run_search = function ()
        	search_loop(search)
        end
        -- item 2967
        db.run_in_fiber(
        	run_search,
        	"search"
        )
        -- item 2744
        return true, {}
    end
end

function search_loop(search)
    while true do
        -- item 2735
        fiber.sleep(search_yield)
        -- item 2733
        if search.state then
            
        else
            break
        end
        -- item 2736
        local now = os.time()
        -- item 2737
        if now > search.expiry then
            break
        end
        -- item 2734
        search:update(nil)
    end
end

function search_machine_completed_default(self, msg)
    -- item 2685
    self.state = "completed"
end

function search_machine_completed_get(self, msg)
    -- item 2690
    take_found_items(self, msg)
    -- item 2756
    msg.completed = true
    -- item 2746
    search_delete(self.session_id)
    -- item 2673
    self.state = nil
end

function search_machine_init_default(self, msg)
    -- item 2634
    self.state = "init"
end

function search_machine_init_update(self, msg)
    -- item 2659
    self.items = {}
    self.session_id = msg.session_id
    self.needle = msg.needle
    self.diagrams = msg.diagrams
    self.current = 1
    -- item 2651
    extend_life(self)
    -- item 2745
    search_add(
    	self.session_id,
    	self
    )
    -- item 2573
    self.state = "scanning"
end

function search_machine_scanning_get(self, msg)
    -- item 2665
    take_found_items(self, msg)
    -- item 2755
    msg.completed = false
    -- item 2664
    extend_life(self)
    -- item 2663
    self.state = "scanning"
end

function search_machine_scanning_update(self, msg)
    -- item 2653
    if self.current > #self.diagrams then
        -- item 2655
        self.state = "completed"
    else
        -- item 2657
        local diagram = self.diagrams[self.current]
        -- item 2658
        search_scan_items(
        	diagram,
        	self.needle,
        	self.items
        )
        -- item 2656
        self.current = self.current + 1
        -- item 2576
        self.state = "scanning"
    end
end

function search_scan_items(diagram, needle, result)
    -- item 2834
    local space_id = diagram.space_id
    local folder_id = diagram.folder_id
    local fields = diagram.fields
    -- item 2774
    local found = {}
    -- item 2775
    local items = db.item_get_by_folder(
    	space_id,
    	folder_id
    )
    -- item 3518
    if fields.params then
        -- item 3535
        seach_text_chunk(
        	"params",
        	fields.params,
        	needle,
        	found
        )
    end
    for _, item_row in ipairs(items) do
        -- item 2778
        local item_id = item_row[3]
        local item = item_row[4]
        -- item 2849
        if item.role == "header" then
            
        else
            -- item 2785
            local text = get_item_text(item)
            local text2 = get_item_text2(item)
            -- item 2797
            if seach_text_chunk(item_id, text, needle, found) then
                
            else
                -- item 3534
                seach_text_chunk(item_id, text2, needle, found)
            end
        end
    end
    -- item 2803
    if #found == 0 then
        
    else
        -- item 2808
        local path = get_short_path(
        	space_id,
        	folder_id
        )
        for _, match in ipairs(found) do
            -- item 2809
            match.space_id = space_id
            match.folder_id = folder_id
            match.name = fields.name
            match.type = fields.type
            match.path = path
            -- item 2810
            table.insert(result, match)
        end
    end
end

function set_folder_props(space_id, folder_id, props, user_id, roles)
    -- item 3238
    db.begin()
    -- item 3235
    local ok, space_error = can_edit_folder(
    	space_id,
    	folder_id,
    	user_id,
    	roles
    )
    -- item 3236
    if ok then
        -- item 3249
        db.folder_props_delete(
        	space_id,
        	folder_id
        )
        for name, value in pairs(props) do
            -- item 3250
            db.folder_props_insert(
            	space_id,
            	folder_id,
            	name,
            	value
            )
        end
        -- item 3246
        db.commit()
        -- item 3244
        return nil
    else
        -- item 3245
        db.rollback()
        -- item 3243
        return space_error
    end
end

function set_space_limits(space_id, max_diagrams, max_users)
    -- item 2046
    local sdata = db.space_get(space_id)
    -- item 2047
    sdata.max_diagrams = max_diagrams
    sdata.max_users = max_users
    -- item 2962
    db.space_update(
    	space_id,
    	sdata
    )
end

function set_theme(user_id, settings)
    for key, value in pairs(settings) do
        -- item 3264
        db.user_props_upsert(
        	user_id,
        	key,
        	value
        )
    end
end

function sort_for_move(items)
    -- item 1365
    local add_depth = function(item)
    	local depth = calculate_depth(
    		item.space_id,
    		item.id
    	)
    	return {
    		id = item.id,
    		space_id = item.space_id,
    		depth = depth
    	}
    end
    -- item 1367
    local result = fun.totable(fun.map(
    	add_depth,
    	items
    ))
    -- item 1366
    local compare_depth = function(left, right)
    	return left.depth > right.depth
    end
    -- item 1368
    table.sort(
    	result,
    	compare_depth
    )
    -- item 1369
    return result
end

function space_exists(space_id, user_id, roles)
    -- item 2955
    local sdata = db.space_get(space_id)
    -- item 1626
    if sdata then
        -- item 1631
        return true
    else
        -- item 1632
        return false
    end
end

function take_found_items(self, dst)
    -- item 2671
    dst.items = self.items
    self.items = {}
end

function top_spaces()
    -- item 2870
    local spaces = db.space_get_all()
    -- item 2874
    local result = {}
    for _, space_row in ipairs(spaces) do
        -- item 2887
        local space_id = space_row[1]
        local admin = get_first_admin(space_id)
        local email = db.user_get_email(admin) or ""
        -- item 2873
        local count = get_diagram_count(space_id)
        local item = {
        	space_id = space_id,
        	user = admin,
        	email = email,
        	count = count
        }
        -- item 2875
        table.insert(result, item)
    end
    -- item 2882
    table.sort(result, by_count)
    -- item 2896
    local txt = ""
    for _, item in ipairs(result) do
        -- item 2897
        txt = txt .. item.space_id .. "\t"
          .. item.user .. "\t"
          .. item.email .. "\t"
          .. item.count .. "\n"
    end
    -- item 2883
    return txt
end

function update_folder(space_id, folder_id, fields, user_id, roles)
    -- item 438
    db.begin()
    -- item 666
    local message
    -- item 435
    local ok, result = can_edit_folder(
    	space_id,
    	folder_id,
    	user_id,
    	roles
    )
    -- item 436
    if ok then
        -- item 454
        local fdata = result
        -- item 3174
        local old_parent = db.folder_tree_get(
        	space_id,
        	folder_id
        )
        -- item 486
        local tag = make_folder_tag()
        -- item 1590
        remember_update(fdata, user_id)
        -- item 1868
        copyNotNil(fields, "name", fdata)
        copyNotNil(fields, "tag", fdata)
        copyNotNil(fields, "background", fdata)
        copyNotNil(fields, "font", fdata)
        copyNotNil(fields, "description", fdata)
        copyNotNil(fields, "keywords", fdata)
        copyNotNil(fields, "params", fdata)
        -- item 3173
        local new_parent = extract_parent_id(
        	fields
        )
        -- item 459
        if (new_parent) and (not (new_parent == old_parent)) then
            -- item 524
            if find_cycle(space_id, folder_id, new_parent) then
                -- item 526
                message = "ERR_CYCLE"
                -- item 440
                db.rollback()
                -- item 439
                return message
            else
                -- item 484
                message = add_child(
                	space_id,
                	new_parent,
                	folder_id,
                	user_id
                )
                -- item 492
                if message then
                    -- item 440
                    db.rollback()
                    -- item 439
                    return message
                else
                    -- item 487
                    fdata.tag = tag
                    -- item 1282
                    remember_update(fdata, user_id)
                    -- item 2935
                    db.folder_update(
                    	space_id,
                    	folder_id,
                    	fdata
                    )
                    -- item 444
                    db.commit()
                    -- item 445
                    return nil
                end
            end
        else
            -- item 487
            fdata.tag = tag
            -- item 1282
            remember_update(fdata, user_id)
            -- item 2935
            db.folder_update(
            	space_id,
            	folder_id,
            	fdata
            )
            -- item 444
            db.commit()
            -- item 445
            return nil
        end
    else
        -- item 667
        message = result
        -- item 440
        db.rollback()
        -- item 439
        return message
    end
end

function update_folder_tag(space_id, folder_id, tag, user_id)
    -- item 788
    local fdata = db.folder_get(space_id, folder_id)
    -- item 1283
    remember_update(fdata, user_id)
    -- item 379
    fdata.tag = tag
    -- item 2936
    db.folder_update(
    	space_id,
    	folder_id,
    	fdata
    )
end

function update_item(space_id, folder_id, item_id, new_data, deleted)
    -- item 415
    local idata = db.item_get(
    	space_id,
    	folder_id,
    	item_id
    )
    -- item 1883
    if idata then
        for key, value in pairs(new_data) do
            -- item 418
            idata[key] = value
        end
        -- item 419
        db.item_update(
        	space_id,
        	folder_id,
        	item_id,
        	idata
        )
    else
        -- item 1886
        log.error("item not found " .. item_id)
        -- item 1890
        if deleted[item_id] then
            
        else
            for key, value in pairs(new_data) do
                -- item 418
                idata[key] = value
            end
            -- item 419
            db.item_update(
            	space_id,
            	folder_id,
            	item_id,
            	idata
            )
        end
    end
end

function update_space_limits(space_id)
    -- item 3031
    local rights = db.rights_get_by_space(
    	space_id
    )
    -- item 3032
    local admins = get_admins(rights)
    -- item 3030
    update_space_limits_core(
    	space_id,
    	admins
    )
end

function update_space_limits_core(space_id, admins)
    -- item 3025
    local max_users = 0
    local max_diagrams = 0
    for _, user_id in ipairs(admins) do
        -- item 3026
        local ulimits = get_user_limits(user_id)
        -- item 3027
        max_users = math.max(
        	max_users,
        	ulimits.max_users
        )
        -- item 3028
        max_diagrams = math.max(
        	max_diagrams,
        	ulimits.max_diagrams
        )
    end
    -- item 3029
    set_space_limits(
    	space_id,
    	max_diagrams,
    	max_users
    )
end


function search_machine()
    local obj = {}
    obj.type_name = "search_machine"
    obj.state = "init"
    obj.get = function(self, msg)
        local _state_ = self.state
        if _state_ == "init" then
            return search_machine_init_default(self, msg)
        elseif _state_ == "scanning" then
            return search_machine_scanning_get(self, msg)
        elseif _state_ == "completed" then
            return search_machine_completed_get(self, msg)
        end
        return nil
    end
    obj.update = function(self, msg)
        local _state_ = self.state
        if _state_ == "init" then
            return search_machine_init_update(self, msg)
        elseif _state_ == "scanning" then
            return search_machine_scanning_update(self, msg)
        elseif _state_ == "completed" then
            return search_machine_completed_default(self, msg)
        end
        return nil
    end
    return obj
end

return {
	create_space = create_space,
	get_folder = get_folder,
	get_tag = get_tag,
	get_theme = get_theme,
	set_theme = set_theme,
	edit = edit,
	create_folder = create_folder,
	update_folder = update_folder,
	delete_many = delete_many,
	copy_many = copy_many,
	move_many = move_many,
	get_trash = get_trash,
	restore = restore,
	clear_trash = clear_trash,
	get_tree = get_tree,
	access = access,
	get_recent = get_recent,
	save_try = save_try,
	read_access = read_access,
	space_exists = space_exists,
	multi_access = multi_access,
	delete_space = delete_space,
	set_space_limits = set_space_limits,
	update_space_limits = update_space_limits,
	get_user_limits = get_user_limits,
	delete_recent = delete_recent,
	delete_theme = delete_theme,
	remove_user = remove_user,
	def_query = def_query,
	get_space_access = get_space_access,
	export_space = export_space,
	import_space = import_space,
	find_folders = find_folders,
	search_delete = search_delete,
	search_items_start = search_items_start,
	search_items_get = search_items_get,
	top_spaces = top_spaces,
	get_folder_props = get_folder_props,
	set_folder_props = set_folder_props,
	get_create_gentoken = get_create_gentoken,
	reset_gentoken = reset_gentoken,
	get_prog_modules = get_prog_modules,
	get_module = get_module,
	check_write_access = check_write_access
}
